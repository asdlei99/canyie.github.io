{"meta":{"title":"残页的小博客","subtitle":null,"description":"残页的小博客~","author":"残页","url":"https://canyie.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-10-30T05:21:23.744Z","updated":"2019-10-30T05:21:23.744Z","comments":true,"path":"404.html","permalink":"https://canyie.github.io/404.html","excerpt":"","text":"404 Not Found 啊哦？页面不见了呢......"},{"title":"关于","date":"2020-04-11T09:31:48.075Z","updated":"2020-04-11T09:31:48.075Z","comments":true,"path":"about/index.html","permalink":"https://canyie.github.io/about/index.html","excerpt":"","text":"本站是残页无聊搭的一个小博客，基于GitHub Pages + Hexo，主题为Volantis 关于我：一个初中生，喜欢编程，喜欢航空。我在这里：QQ聊天 GitHub 知乎 哔哩哔哩 Twitter"},{"title":"所有分类","date":"2019-10-29T04:15:51.429Z","updated":"2019-10-29T04:15:51.429Z","comments":true,"path":"categories/index.html","permalink":"https://canyie.github.io/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-04-11T09:39:31.518Z","updated":"2020-04-11T09:39:31.518Z","comments":true,"path":"friends/index.html","permalink":"https://canyie.github.io/friends/index.html","excerpt":"","text":"各位大佬想交换友链的话可以在 issue区 留言，必须要有名称、头像链接、和至少一个标签哦～ 名称： 残页的小博客头像： https://canyie.github.io/data/image/avatar.jpg网址： https://canyie.github.io/标签： Android"},{"title":"所有标签","date":"2020-04-11T09:30:07.867Z","updated":"2020-04-11T09:30:07.867Z","comments":true,"path":"tags/index.html","permalink":"https://canyie.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-10-30T03:51:51.325Z","updated":"2019-10-30T03:51:51.325Z","comments":true,"path":"data/js/search_children.js","permalink":"https://canyie.github.io/data/js/search_children.js","excerpt":"","text":"var domain='http://qzonestyle.gtimg.cn/qzone_v6/lostchild/';document.write('');document.write('');/* |xGv00|2c679710685b04aaa3216bae2b68a58c */"}],"posts":[{"title":"一种在ART上快速加载dex的方法","slug":"fast-load-dex-on-art-runtime","date":"2020-02-15T02:02:33.000Z","updated":"2020-04-15T03:08:44.350Z","comments":true,"path":"2020/02/15/fast-load-dex-on-art-runtime/","link":"","permalink":"https://canyie.github.io/2020/02/15/fast-load-dex-on-art-runtime/","excerpt":"在国内的大环境下，Android上插件化/热修复等技术百花齐放，而这一切都基于代码的动态加载。Android提供了一个DexClassLoader。用这个API能成功加载dex，但有一个比较严重的问题：Android Q以下，当这个dex被加载时，如果没有已经生成的oat，则会执行一次dex2oat把这个dex编译为oat，导致第一次加载dex会非常非常慢。个人认为这样的设计是非常不合理的，虽然转换成oat之后执行会很快，但完全可以让用户以解释器模式先愉快的用着，dex2oat放另一个线程执行多好。Android 8.0上谷歌还提供了一个InMemoryDexClassLoader，而以前的Android版本，就要开发者自己想办法了……","text":"在国内的大环境下，Android上插件化/热修复等技术百花齐放，而这一切都基于代码的动态加载。Android提供了一个DexClassLoader。用这个API能成功加载dex，但有一个比较严重的问题：Android Q以下，当这个dex被加载时，如果没有已经生成的oat，则会执行一次dex2oat把这个dex编译为oat，导致第一次加载dex会非常非常慢。个人认为这样的设计是非常不合理的，虽然转换成oat之后执行会很快，但完全可以让用户以解释器模式先愉快的用着，dex2oat放另一个线程执行多好。Android 8.0上谷歌还提供了一个InMemoryDexClassLoader，而以前的Android版本，就要开发者自己想办法了…… 源码分析注：为了说明此方法能在较低版本的ART上运行，本文分析的源码是Android 5.0的源码，之后的Android版本里OpenDexFileFromOat方法搬到了OatFileManager里，而调用dex2oat的部分则重构到了OatFileAssistant中，大致逻辑相同，感兴趣的可以自己去看看；至于Android 4.4，简单扫了一下源码似乎是生成oat失败就会直接抛一个IOException拒绝加载，emmm…… 我们在Java代码里用new DexClassLoader()的方式加载dex，最后会调用到DexFile.openDexFileNative中，这个函数的实现是这样的： 12345678910111213141516171819202122232425static jlong DexFile_openDexFileNative(JNIEnv* env, jclass, jstring javaSourceName, jstring javaOutputName, jint) &#123; ScopedUtfChars sourceName(env, javaSourceName); if (sourceName.c_str() == NULL) &#123; return 0; &#125; NullableScopedUtfChars outputName(env, javaOutputName); if (env-&gt;ExceptionCheck()) &#123; return 0; &#125; ClassLinker* linker = Runtime::Current()-&gt;GetClassLinker(); std::unique_ptr&lt;std::vector&lt;const DexFile*&gt;&gt; dex_files(new std::vector&lt;const DexFile*&gt;()); std::vector&lt;std::string&gt; error_msgs; bool success = linker-&gt;OpenDexFilesFromOat(sourceName.c_str(), outputName.c_str(), &amp;error_msgs, dex_files.get()); if (success || !dex_files-&gt;empty()) &#123; // In the case of non-success, we have not found or could not generate the oat file. // But we may still have found a dex file that we can use. return static_cast&lt;jlong&gt;(reinterpret_cast&lt;uintptr_t&gt;(dex_files.release())); &#125; else &#123; // 加载失败的情况，省略 &#125;&#125; 这里的注释很有意思，如果返回false（生成oat失败），但是有被成功加载的dex，那么还是应该当做成功。可以看出具体实现在ClassLinker中的OpenDexFilesFromOat里，我们点进去看看： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117// Multidex files make it possible that some, but not all, dex files can be broken/outdated. This// complicates the loading process, as we should not use an iterative loading process, because that// would register the oat file and dex files that come before the broken one. Instead, check all// multidex ahead of time.bool ClassLinker::OpenDexFilesFromOat(const char* dex_location, const char* oat_location, std::vector&lt;std::string&gt;* error_msgs, std::vector&lt;const DexFile*&gt;* dex_files) &#123; // 1) Check whether we have an open oat file. // This requires a dex checksum, use the \"primary\" one. bool needs_registering = false; const OatFile::OatDexFile* oat_dex_file = FindOpenedOatDexFile(oat_location, dex_location, dex_location_checksum_pointer); std::unique_ptr&lt;const OatFile&gt; open_oat_file( oat_dex_file != nullptr ? oat_dex_file-&gt;GetOatFile() : nullptr); // 2) If we do not have an open one, maybe there's one on disk already. // In case the oat file is not open, we play a locking game here so // that if two different processes race to load and register or generate // (or worse, one tries to open a partial generated file) we will be okay. // This is actually common with apps that use DexClassLoader to work // around the dex method reference limit and that have a background // service running in a separate process. ScopedFlock scoped_flock; if (open_oat_file.get() == nullptr) &#123; if (oat_location != nullptr) &#123; std::string error_msg; // We are loading or creating one in the future. Time to set up the file lock. if (!scoped_flock.Init(oat_location, &amp;error_msg)) &#123; error_msgs-&gt;push_back(error_msg); return false; &#125; // TODO Caller specifically asks for this oat_location. We should honor it. Probably? open_oat_file.reset(FindOatFileInOatLocationForDexFile(dex_location, dex_location_checksum, oat_location, &amp;error_msg)); if (open_oat_file.get() == nullptr) &#123; std::string compound_msg = StringPrintf(\"Failed to find dex file '%s' in oat location '%s': %s\", dex_location, oat_location, error_msg.c_str()); VLOG(class_linker) &lt;&lt; compound_msg; error_msgs-&gt;push_back(compound_msg); &#125; &#125; else &#123; // TODO: What to lock here? bool obsolete_file_cleanup_failed; open_oat_file.reset(FindOatFileContainingDexFileFromDexLocation(dex_location, dex_location_checksum_pointer, kRuntimeISA, error_msgs, &amp;obsolete_file_cleanup_failed)); // There's no point in going forward and eventually try to regenerate the // file if we couldn't remove the obsolete one. Mostly likely we will fail // with the same error when trying to write the new file. // TODO: should we maybe do this only when we get permission issues? (i.e. EACCESS). if (obsolete_file_cleanup_failed) &#123; return false; &#125; &#125; needs_registering = true; &#125; // 3) If we have an oat file, check all contained multidex files for our dex_location. // Note: LoadMultiDexFilesFromOatFile will check for nullptr in the first argument. bool success = LoadMultiDexFilesFromOatFile(open_oat_file.get(), dex_location, dex_location_checksum_pointer, false, error_msgs, dex_files); if (success) &#123; // 我们没有有效的oat文件，所以不会走到这里 &#125; else &#123; if (needs_registering) &#123; // We opened it, delete it. open_oat_file.reset(); &#125; else &#123; open_oat_file.release(); // Do not delete open oat files. &#125; &#125; // 4) If it's not the case (either no oat file or mismatches), regenerate and load. // Look in cache location if no oat_location is given. std::string cache_location; if (oat_location == nullptr) &#123; // Use the dalvik cache. const std::string dalvik_cache(GetDalvikCacheOrDie(GetInstructionSetString(kRuntimeISA))); cache_location = GetDalvikCacheFilenameOrDie(dex_location, dalvik_cache.c_str()); oat_location = cache_location.c_str(); &#125; bool has_flock = true; // Definitely need to lock now. if (!scoped_flock.HasFile()) &#123; std::string error_msg; if (!scoped_flock.Init(oat_location, &amp;error_msg)) &#123; error_msgs-&gt;push_back(error_msg); has_flock = false; &#125; &#125; if (Runtime::Current()-&gt;IsDex2OatEnabled() &amp;&amp; has_flock &amp;&amp; scoped_flock.HasFile()) &#123; // Create the oat file. open_oat_file.reset(CreateOatFileForDexLocation(dex_location, scoped_flock.GetFile()-&gt;Fd(), oat_location, error_msgs)); &#125; // Failed, bail. if (open_oat_file.get() == nullptr) &#123; // 如果无法生成oat，那么直接加载dex std::string error_msg; // dex2oat was disabled or crashed. Add the dex file in the list of dex_files to make progress. DexFile::Open(dex_location, dex_location, &amp;error_msg, dex_files); error_msgs-&gt;push_back(error_msg); return false; &#125; // 再次尝试加载oat，无关，省略&#125; 这个函数比较长，所以做了一点精简。我们在这里看到了一点端倪，这个函数做了这些事情： 检查我们是否已经有一个打开了的oat 如果没有，那么检查oat缓存目录（创建DexClassLoader时传入的第二个参数）是否已经有了一个oat，并且检查这个oat的有效性 如果没有或者这个oat是无效的，那么生成一个oat文件 我们首次加载dex时，肯定没有有效的oat，最后会生成一个新的oat： 12345if (Runtime::Current()-&gt;IsDex2OatEnabled() &amp;&amp; has_flock &amp;&amp; scoped_flock.HasFile()) &#123; // Create the oat file. open_oat_file.reset(CreateOatFileForDexLocation(dex_location, scoped_flock.GetFile()-&gt;Fd(), oat_location, error_msgs));&#125; 这里有一个if判断，直接决定是否进行dex2oat，我们看看能不能通过各种手段让这个判断不成立。 禁用dex2oat第一招：修改Runtime中的变量这个if判断里，第一个条件就是Runtime::Current()-&gt;IsDex2OatEnabled()，如果返回false，那么就不会生成oat。这个函数的实现如下： 1234567bool IsDex2OatEnabled() const &#123; return dex2oat_enabled_ &amp;&amp; IsImageDex2OatEnabled();&#125;bool IsImageDex2OatEnabled() const &#123; return image_dex2oat_enabled_;&#125; dex2oat_enabled_与image_dex2oat_enabled_都是Runtime对象中的成员变量，而Runtime可以通过JavaVM获取，所以我们只需要修改这个值就能禁用dex2oat。已经有其他人实现了这一步，具体可以看看这篇博客。然而事情真的会这么简单吗？查看源码发现Runtime是一个炒鸡大的结构体，Android里有什么东西都往这扔，你几乎可以从Runtime对象上直接或间接获取到任何东西，然而也正是因为Runtime太大了，使得没有什么好的办法获取里面的值。 让我们看看还有没有其他方法： 第二招：使用PathClassLoader我们可以看见，在if判断里，还有两个条件：has_flock和scoped_flock.HasFile()，让我们看看是否可以让这两个条件不成立。has_flock的赋值： 123456789bool has_flock = true;// Definitely need to lock now.if (!scoped_flock.HasFile()) &#123; std::string error_msg; if (!scoped_flock.Init(oat_location, &amp;error_msg)) &#123; error_msgs-&gt;push_back(error_msg); has_flock = false; &#125;&#125; 又是scoped_flock，看看在上面scoped_flock可能在哪里被初始化： 12345678910111213ScopedFlock scoped_flock;if (open_oat_file.get() == nullptr) &#123; if (oat_location != nullptr) &#123; std::string error_msg; // We are loading or creating one in the future. Time to set up the file lock. if (!scoped_flock.Init(oat_location, &amp;error_msg)) &#123; error_msgs-&gt;push_back(error_msg); return false; &#125; // 省略代码 &#125;&#125; 看看ScopedFlock的Init方法： 12345678910bool ScopedFlock::Init(const char* filename, std::string* error_msg) &#123; while (true) &#123; file_.reset(OS::OpenFileWithFlags(filename, O_CREAT | O_RDWR)); if (file_.get() == NULL) &#123; *error_msg = StringPrintf(\"Failed to open file '%s': %s\", filename, strerror(errno)); return false; &#125; // 省略一大堆代码…… &#125;&#125; 可以看见，会打开这个文件，flags为O_CREAT | O_RDWR，那我们只需要设置oat_location为不可写的路径，就能让ScopedFlock::Init返回false。不过我们要注意的是，如果oat_location不为null并且无法使用，那在上面的一个判断里就会直接返回false。怎么办？ 是时候请出我们的主角PathClassLoader了！ PathClassLoader作为DexClassLoader的兄弟（也可能是姐妹？），受到的待遇与DexClassLoader截然不同：网上讲解动态加载dex的文章几乎都只讲DexClassLoader，而对于PathClassLoader则是一笔带过：“PathClassLoader只能加载系统中已经安装过的apk”。然而事实真的是这样吗？或许Android 5.0以前是，但Android 5.0时就已经可以加载外部dex了，今天我要为PathClassLoader正名！让我们来对比一下DexClassLoader和PathClassLoader的源码。DexClassLoader： 123456public class DexClassLoader extends BaseDexClassLoader &#123; public DexClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent) &#123; super(dexPath, new File(optimizedDirectory), libraryPath, parent); &#125;&#125; 对，你没看错，有效代码就这么点。让我们再看看PathClassLoader的源码： 12345678910public class PathClassLoader extends BaseDexClassLoader &#123; public PathClassLoader(String dexPath, ClassLoader parent) &#123; super(dexPath, null, null, parent); &#125; public PathClassLoader(String dexPath, String libraryPath, ClassLoader parent) &#123; super(dexPath, null, libraryPath, parent); &#125;&#125; 实际上所以实现代码都在BaseDexClassLoader中，DexClassLoader和PathClassLoader都调用了同一个构造函数： 123456789public class BaseDexClassLoader extends ClassLoader &#123; private final DexPathList pathList; public BaseDexClassLoader(String dexPath, File optimizedDirectory, String libraryPath, ClassLoader parent) &#123; super(parent); this.pathList = new DexPathList(this, dexPath, libraryPath, optimizedDirectory); &#125;&#125; 注意第二个参数，optimizedDirectory，DexClassLoader传入的是new File(optimizedDirectory)，而PathClassLoader传入的是null。记住这一点。这两种情况最后都会调用到DexFile.openDexFileNative中 1private static native long openDexFileNative(String sourceName, String outputName, int flags); 如果是PathClassLoader，outputName为null，会进入这个if分支中： 12345678// Look in cache location if no oat_location is given.std::string cache_location;if (oat_location == nullptr) &#123; // Use the dalvik cache. const std::string dalvik_cache(GetDalvikCacheOrDie(GetInstructionSetString(kRuntimeISA))); cache_location = GetDalvikCacheFilenameOrDie(dex_location, dalvik_cache.c_str()); oat_location = cache_location.c_str();&#125; 这里会把oat_location设置成/data/dalvik-cache/下的路径，接下来因为我们根本没有对dalvik-cache的写入权限，所以无法打开fd，然后就会走到这里直接加载原始dex： 1234567if (open_oat_file.get() == nullptr) &#123; std::string error_msg; // dex2oat was disabled or crashed. Add the dex file in the list of dex_files to make progress. DexFile::Open(dex_location, dex_location, &amp;error_msg, dex_files); error_msgs-&gt;push_back(error_msg); return false;&#125; 至此整个逻辑已经明朗，通过PathClassLoader加载会把oat输出路径设置成/data/dalvik-cache/下，然后因为我们没有对dalvik-cache的写入权限，所以无法打开fd，之后会直接加载原始dex，不会进行dex2oat。（注：本文分析源码是Android 5.0，在Android 8.1时源码有改动，就算是DexClassLoader也会把optimizedDirectory设置成null，输出的oat在dex的父目录/oat/下，所以无法通过PathClassLoader快速加载dex，但在8.1时已经有InMemoryDexClassLoader了，直接通过InMemoryDexClassLoader加载就好了。 简单做了个小测试，在我的AVD（Android 7.1.1）上，用DexClassLoader加载75M的qq apk用了近80秒，并生成了一个313M的oat，而PathClassLoader用时稳定在2秒左右，emmm…… 看起来我们已经有一个比较好的办法禁用dex2oat了，不过需要修改源码没法直接全局禁用，修改Runtime风险又太大，让我们看看还有没有其他方法。 第三招：hook execv到了这里，上面那个判断肯定会成立了，似乎进行dex2oat已成定局？我们继续看CreateOatFileForDexLocation。 1234567891011121314151617181920212223const OatFile* ClassLinker::CreateOatFileForDexLocation(const char* dex_location, int fd, const char* oat_location, std::vector&lt;std::string&gt;* error_msgs) &#123; // Generate the output oat file for the dex file VLOG(class_linker) &lt;&lt; \"Generating oat file \" &lt;&lt; oat_location &lt;&lt; \" for \" &lt;&lt; dex_location; std::string error_msg; if (!GenerateOatFile(dex_location, fd, oat_location, &amp;error_msg)) &#123; CHECK(!error_msg.empty()); error_msgs-&gt;push_back(error_msg); return nullptr; &#125; std::unique_ptr&lt;OatFile&gt; oat_file(OatFile::Open(oat_location, oat_location, nullptr, !Runtime::Current()-&gt;IsCompiler(), &amp;error_msg)); if (oat_file.get() == nullptr) &#123; std::string compound_msg = StringPrintf(\"\\nFailed to open generated oat file '%s': %s\", oat_location, error_msg.c_str()); error_msgs-&gt;push_back(compound_msg); return nullptr; &#125; return oat_file.release();&#125; GenerateOatFile是核心逻辑，这个函数大部分都是我们不关心的配置dex2oat参数就不贴出来了，最后会fork出一个新进程，然后在子进程里执行execv()调用dex2oat。看起来我们必然要执行dex2oat了？别慌，还有办法。虽然没有直接的开关去阻止dex2oat，但我们还有hook大法！生成oat最后是通过execv调用dex2oat进行的，所以我们可以hook掉execv函数，如果是执行dex2oat那么直接让这个进程退出即可！Lody大神的早期作品TurboDex就是这样实现的。不过这个项目其实还可以优化一下：TurboDex是使用的Substrate进行hook，这是一个inline hook库，而execv是来自libc.so的导出符号，其实直接通过GOT Hook就能hook到，没有必要去用inline hook，反而增加crash风险。 总结本来我只是为了研究DexClassLoader与PathClassLoader的区别的，网上的文章和实验的结果完全不一样，结果意外发现一个快速加载dex的方法，就写出来了 :)这个故事告诉我们，没事多看源码（手动滑稽）另外个人建议，快速加载dex之后后台可以开一个线程单独进行dex2oat，具体可以参考ArtDexOptimizer，下次启动的时候如果完成了可以直接用生成好的oat文件，毕竟用oat比直接加载dex快得多，而且更稳定~","categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://canyie.github.io/tags/android/"},{"name":"art","slug":"art","permalink":"https://canyie.github.io/tags/art/"},{"name":"dex","slug":"dex","permalink":"https://canyie.github.io/tags/dex/"}]},{"title":"试着写了一个类Xposed框架","slug":"a-new-xposed-style-framework","date":"2020-02-03T06:51:21.000Z","updated":"2020-02-05T06:10:23.000Z","comments":true,"path":"2020/02/03/a-new-xposed-style-framework/","link":"","permalink":"https://canyie.github.io/2020/02/03/a-new-xposed-style-framework/","excerpt":"新人第一次写博客，勿喷..本文也发布在知乎上 Xposed框架在Android上是神器般的存在，它给了普通用户随意定制系统的能力，各种骚操作层出不穷。随着咱对Android的了解越来越深（其实一点都不深..），逐渐冒出了自己写一个类Xposed框架的想法，最终搞出了这个勉强能用的半成品。代码在这：Dreamland &amp; Dreamland Manager ，代码写的很辣鸡，求轻喷QAQ接下来会介绍一下实现细节与遇到的问题。","text":"新人第一次写博客，勿喷..本文也发布在知乎上 Xposed框架在Android上是神器般的存在，它给了普通用户随意定制系统的能力，各种骚操作层出不穷。随着咱对Android的了解越来越深（其实一点都不深..），逐渐冒出了自己写一个类Xposed框架的想法，最终搞出了这个勉强能用的半成品。代码在这：Dreamland &amp; Dreamland Manager ，代码写的很辣鸡，求轻喷QAQ接下来会介绍一下实现细节与遇到的问题。 注入 zygote 进程我们想实现Xposed那样在目标进程加载自己的模块，就必须把我们自己的代码注入到目标进程，而且我们的代码执行的时机还需要足够早，一般来说都是选择直接注入到zygote进程。 先来看看其他框架的实现： Xposed ：Xposed for art 重新实现了app_process，libart.so等重要系统库，安装时会替换这些文件，而各大厂商几乎没有不修改它们的，一旦被替换很可能变砖，导致Xposed在非原生系统上的稳定性很差。 EdXposed : EdXp依赖 Riru 而Riru是通过替换libmemtrack.so来实现，这个so库会在zygote进程启动时被加载，并且比libart轻得多（只有10个导出函数），然后就可以在zygote进程里执行任意代码。 太极阳 : 太极阳通过一种我看不懂的魔法（看了一下只发现libjit.so，但weishu表示Android系统里并没有一个这样一个库，所以并不是简单替换so）注入进zygote（以前是替换libprocessgroup.so） 可以看出，其他框架几乎都通过直接替换系统已有的so库实现，而替换已有so库则需要尽量选择较轻的库，以避免厂商的修改导致的问题。然而，我们没法避免厂商在so里加料，如果厂商修改了这个so库，我们直接把我们自己以AOSP为蓝本写的so替换上去，则会导致严重的问题。有没有别的什么办法？下面介绍梦境的实现方式。（注：如无特别说明，本文中的AOSP源码都是 7.0.0_r36 对应的代码）我们知道，在android中，所有的应用进程都是由zygote进程fork出来的，而zygote对应的可执行文件就是app_process（具体可以看init.rc）app_process的main方法如下： 12345678910111213141516int main(int argc, char* const argv[])&#123; // 省略无关代码... AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv)); // 省略无关代码... if (zygote) &#123; runtime.start(\"com.android.internal.os.ZygoteInit\", args, zygote); &#125; else if (className) &#123; runtime.start(\"com.android.internal.os.RuntimeInit\", args, zygote); &#125; else &#123; fprintf(stderr, \"Error: no class name or --zygote supplied.\\n\"); app_usage(); LOG_ALWAYS_FATAL(\"app_process: no class name or --zygote supplied.\"); return 10; &#125;&#125; 可以发现，是通过AppRuntime启动的，而AppRuntime继承自AndroidRuntime，start方法的实现在AndroidRuntime里 1234567891011121314151617181920212223242526272829/* * Start the Android runtime. This involves starting the virtual machine * and calling the \"static void main(String[] args)\" method in the class * named by \"className\". * * Passes the main function two arguments, the class name and the specified * options string. */void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote)&#123; // 省略无关代码... /* start the virtual machine */ JniInvocation jni_invocation; jni_invocation.Init(NULL); JNIEnv* env; if (startVm(&amp;mJavaVM, &amp;env, zygote) != 0) &#123; return; &#125; onVmCreated(env); /* * Register android functions. */ if (startReg(env) &lt; 0) &#123; ALOGE(\"Unable to register all android natives\\n\"); return; &#125; // 省略无关代码...&#125; 注意startVm这个方法，我们点进去看看。 1234567891011121314151617181920212223242526272829303132/* * Start the Dalvik Virtual Machine. * * Various arguments, most determined by system properties, are passed in. * The \"mOptions\" vector is updated. * * CAUTION: when adding options in here, be careful not to put the * char buffer inside a nested scope. Adding the buffer to the * options using mOptions.add() does not copy the buffer, so if the * buffer goes out of scope the option may be overwritten. It's best * to put the buffer at the top of the function so that it is more * unlikely that someone will surround it in a scope at a later time * and thus introduce a bug. * * Returns 0 on success. */int AndroidRuntime::startVm(JavaVM** pJavaVM, JNIEnv** pEnv, bool zygote)&#123; // 省略无关代码... /* * Initialize the VM. * * The JavaVM* is essentially per-process, and the JNIEnv* is per-thread. * If this call succeeds, the VM is ready, and we can start issuing * JNI calls. */ if (JNI_CreateJavaVM(pJavaVM, pEnv, &amp;initArgs) &lt; 0) &#123; ALOGE(\"JNI_CreateJavaVM failed\\n\"); return -1; &#125; return 0;&#125; 接下来看JNI_CreateJavaVM方法： 123456789101112131415161718192021222324252627282930313233343536// JNI Invocation interface.extern \"C\" jint JNI_CreateJavaVM(JavaVM** p_vm, JNIEnv** p_env, void* vm_args) &#123; ScopedTrace trace(__FUNCTION__); const JavaVMInitArgs* args = static_cast&lt;JavaVMInitArgs*&gt;(vm_args); if (IsBadJniVersion(args-&gt;version)) &#123; LOG(ERROR) &lt;&lt; \"Bad JNI version passed to CreateJavaVM: \" &lt;&lt; args-&gt;version; return JNI_EVERSION; &#125; RuntimeOptions options; for (int i = 0; i &lt; args-&gt;nOptions; ++i) &#123; JavaVMOption* option = &amp;args-&gt;options[i]; options.push_back(std::make_pair(std::string(option-&gt;optionString), option-&gt;extraInfo)); &#125; bool ignore_unrecognized = args-&gt;ignoreUnrecognized; if (!Runtime::Create(options, ignore_unrecognized)) &#123; return JNI_ERR; &#125; // Initialize native loader. This step makes sure we have // everything set up before we start using JNI. android::InitializeNativeLoader(); Runtime* runtime = Runtime::Current(); bool started = runtime-&gt;Start(); if (!started) &#123; delete Thread::Current()-&gt;GetJniEnv(); delete runtime-&gt;GetJavaVM(); LOG(WARNING) &lt;&lt; \"CreateJavaVM failed\"; return JNI_ERR; &#125; *p_env = Thread::Current()-&gt;GetJniEnv(); *p_vm = runtime-&gt;GetJavaVM(); return JNI_OK;&#125; 这个函数不长，我就直接全部贴出来了。注意看android::InitializeNativeLoader()，这个函数直接调用了g_namespaces-&gt;Initialize()，而g_namespaces是一个LibraryNamespaces指针，继续看下去，我们发现了宝藏： 123456789101112131415161718192021222324252627282930void Initialize() &#123; std::vector&lt;std::string&gt; sonames; const char* android_root_env = getenv(\"ANDROID_ROOT\"); std::string root_dir = android_root_env != nullptr ? android_root_env : \"/system\"; std::string public_native_libraries_system_config = root_dir + kPublicNativeLibrariesSystemConfigPathFromRoot; LOG_ALWAYS_FATAL_IF(!ReadConfig(public_native_libraries_system_config, &amp;sonames), \"Error reading public native library list from \\\"%s\\\": %s\", public_native_libraries_system_config.c_str(), strerror(errno)); // 省略无关代码 // This file is optional, quietly ignore if the file does not exist. ReadConfig(kPublicNativeLibrariesVendorConfig, &amp;sonames); // android_init_namespaces() expects all the public libraries // to be loaded so that they can be found by soname alone. // // TODO(dimitry): this is a bit misleading since we do not know // if the vendor public library is going to be opened from /vendor/lib // we might as well end up loading them from /system/lib // For now we rely on CTS test to catch things like this but // it should probably be addressed in the future. for (const auto&amp; soname : sonames) &#123; dlopen(soname.c_str(), RTLD_NOW | RTLD_NODELETE); &#125; public_libraries_ = base::Join(sonames, ':');&#125; public_native_libraries_system_config=/system/etc/public.libraries.txt，而ReadConfig方法很简单，读取传进来的文件路径，按行分割，忽略空行和以#开头的行，然后把这行push_back到传进来的vector里。所以这个函数做了这几件事： 读取/system/etc/public.libraries.txt和/vendor/etc/public.libraries.txt 挨个dlopen这两个txt文件里提到的所有so库 注：这里分析的源码是7.0.0的，在7.0往后的所有版本（截至本文发布）你都能找到类似的逻辑。 知道了这件事注入zygote就好办多了嘛！只要把我们自己写的so库扔到/system/lib下面（64位是/syste/lib64），然后在/system/etc/public.libraries.txt里把我们自己的文件加上去，这样zygote启动的时候就会去加载我们的so库，然后我们写一个函数，加上__attribute__((constructor))，这样这个函数就会在so库被加载的时候被调用，我们就完成了注入逻辑；而且这个文件是一个txt文件，只需要追加一行文件名就行，即使厂商做了修改也不用担心，稳定性棒棒哒！ （注1：此方法是我看一篇博客时看见的，那篇博客吐槽“在public.libraries.txt里加上的so库竟然会在zygote启动时被加载，每次修改都要重启手机才能生效，多不方便调试”，但是他抱怨的特性却成为了我的曙光，可惜找不到那篇博客了，没法贴出来…）（注2：在我大致完成了核心逻辑之后，我在EdXp的源码里发现了这个文件 ；这个部分看起来是使用whale进行java hook的方案，但是我从来没有听说过有使用纯whale进行java hook的EdXp版本，并且我在install.sh中没有看见操作public.libraries.txt，所以不太懂他想用这个文件干什么 :( ） ok，现在我们完成了注入zygote进程的逻辑，刚完成的时候我想，完成了注入部分，ART Hook部分也有很多开源库，那么实现一个xposed不是很简单的事吗？果然我还是太年轻… 监控应用进程启动前面我们注入了zygote进程，然而这样还不够，我们还需要监控应用进程启动并在应用进程执行代码才行。 刚开始我的想法很简单：直接在zygote里随便用art hook技术hook掉几个java方法；不过在我们的so库被加载的时候Runtime还没启动完成，没法拿到JNIEnv（就算拿到也用不了），这个也好办，native inline hook掉几个会在Runtime初始化完成时调用的函数就行，然并卵，提示无法分配可执行内存。 wtf？？为什么分配内存会失败？内存满了？没对齐？最后终于发现这样一条log： type=1400 audit(0.0:5): avc: denied { execmem } for scontext=u:r:zygote:s0 tcontext=u:r:zygote:s0 tclass=process permissive=0 上网查了一下，这条log代表zygote进程的context（u:r:zygote:s0）不允许分配可执行的匿名内存。这就麻烦了呀，很多事都做不了了（包括java方法的inline hook），想过很多办法（比如替换sepolicy），最后都被我否决了。那怎么办？最后打算去看EdXp的处理方式，没看见任何有关SELinux的部分，似乎是让magisk处理，不过我的是模拟器，没法装magisk。 这个问题困扰了我很久，最后，在Riru的源码里发现了另一种实现方案：通过GOT Hook拦截jniRegisterNativeMethods，然后就可以替换部分关键JNI函数。 简单来说，当发生跨ELF的函数调用时，会去.got表里查这个函数的绝对地址，然后再跳转过去，所以我们直接改这个表就能达到hook的目的，更多实现细节可以看xhook的说明文档。 这种方式的好处是不需要直接操作内存中的指令，不需要去手动分配可执行内存，所以不会受到SELinux的限制；缺点也很明显，如果人家不查.got表，就无法hook了。所以这种方式一般用于hook系统函数，比如来自libc的malloc, open等函数。 好了，GOT Hook并不是重点，接下来Riru使用xhook hook了libandroid_runtime.so对jniRegisterNativeMethods方法（来自libnativehelper.so）的调用，这样就能拦截一部分的JNI方法调用了。为什么说是一部分？因为另一部分JNI函数的实现在libart里，这一部分函数直接通过env-&gt;RegisterNativeMethods完成注册，所以无法hook。 之后riru在被替换的jniRegisterNativeMethods中动了一点小手脚：如果正在注册来自Zygote类的JNI方法，那么会把nativeForkSystemServer和nativeForkAndSpecialize替换成自己的实现，这样就能拦截system_server与应用进程的启动了！ Riru的这个方案非常好，但是还有优化空间：nativeForkAndSpecialize这个函数基本上每个版本都会变签名，而且各个厂商也会做修改，Riru的办法很简单：比对签名，如果签名不对那么就不会替换。不过，实际上我们并不需要那么精密的监控进程启动，让我们来找一下有没有其他的hook点。 大家都知道的，zygote进程最终会进入ZygoteInit.main，在main方法里fork出system_server，然后进入死循环接收来自AMS的请求fork出新进程。 12345678910public static void main(String argv[]) &#123; // 省略无关代码... if (startSystemServer) &#123; startSystemServer(abiList, socketName); &#125; // 省略无关代码... Log.i(TAG, \"Accepting command socket connections\"); runSelectLoop(abiList); // 省略无关代码...&#125; 在startSystemServer里会fork出system_server，runSelectLoop中会进入死循环等待创建进程请求，然后fork出应用进程。 12345678910111213141516171819202122/** * Prepare the arguments and fork for the system server process. */private static boolean startSystemServer(String abiList, String socketName) throws MethodAndArgsCaller, RuntimeException &#123; // 省略无关代码... /* Request to fork the system server process */ pid = Zygote.forkSystemServer( parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, null, parsedArgs.permittedCapabilities, parsedArgs.effectiveCapabilities); /* For child process */ if (pid == 0) &#123; // 注：返回0代表子进程 if (hasSecondZygote(abiList)) &#123; waitForSecondaryZygote(socketName); &#125; handleSystemServerProcess(parsedArgs); &#125;&#125; 点进去handleSystemServerProcess里看看： 12345678910111213141516171819202122/** * Finish remaining work for the newly forked system server process. */ private static void handleSystemServerProcess( ZygoteConnection.Arguments parsedArgs) throws ZygoteInit.MethodAndArgsCaller &#123; // 省略无关代码... if (parsedArgs.invokeWith != null) &#123; // 走不进去，省略 &#125; else &#123; ClassLoader cl = null; if (systemServerClasspath != null) &#123; cl = createSystemServerClassLoader(systemServerClasspath, parsedArgs.targetSdkVersion); Thread.currentThread().setContextClassLoader(cl); &#125; /* * Pass the remaining arguments to SystemServer. */ RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl); &#125; &#125; 最终会进入RuntimeInit.zygoteInit（7.x，对于8.x与以上在ZygoteInit.zygoteInit），记住这一点 然后，应用进程的创建是在runSelectLoop()里，最后会通过ZygoteConnection.runOnce进行处理 12345678910111213141516171819202122232425262728293031323334/** * Reads one start command from the command socket. If successful, * a child is forked and a &#123;@link ZygoteInit.MethodAndArgsCaller&#125; * exception is thrown in that child while in the parent process, * the method returns normally. On failure, the child is not * spawned and messages are printed to the log and stderr. Returns * a boolean status value indicating whether an end-of-file on the command * socket has been encountered. * * @return false if command socket should continue to be read from, or * true if an end-of-file has been encountered. * @throws ZygoteInit.MethodAndArgsCaller trampoline to invoke main() * method in child process */boolean runOnce() throws ZygoteInit.MethodAndArgsCaller &#123; //忽略无关代码 pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet, parsedArgs.appDataDir); // 忽略无关代码 if (pid == 0) &#123; // 子进程 // in child IoUtils.closeQuietly(serverPipeFd); serverPipeFd = null; handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr); // should never get here, the child is expected to either // throw ZygoteInit.MethodAndArgsCaller or exec(). return true; &#125; else &#123; // 忽略 &#125;&#125; 12345678910111213141516171819202122232425/** * Handles post-fork setup of child proc, closing sockets as appropriate, * reopen stdio as appropriate, and ultimately throwing MethodAndArgsCaller * if successful or returning if failed. * * @param parsedArgs non-null; zygote args * @param descriptors null-ok; new file descriptors for stdio if available. * @param pipeFd null-ok; pipe for communication back to Zygote. * @param newStderr null-ok; stream to use for stderr until stdio * is reopened. * * @throws ZygoteInit.MethodAndArgsCaller on success to * trampoline to code that invokes static main. */private void handleChildProc(Arguments parsedArgs, FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr) throws ZygoteInit.MethodAndArgsCaller &#123; // 忽略无关代码 if (parsedArgs.invokeWith != null) &#123; // 走不进去，省略 &#125; else &#123; RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, null /* classLoader */); &#125;&#125; 最后也是通过RuntimeInit.zygoteInit（7.x，对于8.x与以上在ZygoteInit.zygoteInit）完成。点进去看看有没有hook点： 123456789101112131415161718192021222324/** * The main function called when started through the zygote process. This * could be unified with main(), if the native code in nativeFinishInit() * were rationalized with Zygote startup.&lt;p&gt; * * Current recognized args: * &lt;ul&gt; * &lt;li&gt; &lt;code&gt; [--] &amp;lt;start class name&amp;gt; &amp;lt;args&amp;gt; * &lt;/ul&gt; * * @param targetSdkVersion target SDK version * @param argv arg strings */public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; if (DEBUG) Slog.d(TAG, \"RuntimeInit: Starting application from zygote\"); Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"RuntimeInit\"); redirectLogStreams(); commonInit(); nativeZygoteInit(); applicationInit(targetSdkVersion, argv, classLoader);&#125; 注意到那个nativeZygoteInit没有！！很明显是个native方法，而且是我们可以hook到的native方法！！这样子我们就可以直接在jniRegisterNativeMethods里替换掉这个方法了！而且这个方法从7.0到10.0也只有过一次改变：从RuntimeInit搬到ZygoteInit，比nativeForkAndSpecialize稳得多。（然而现在看来某些操作还是需要比较精细的监控的，以后再改吧） 加载Xposed模块这一部分其实是最简单的，目前已经有很多开源的ART Hook库，拿来就能用，需要自己写的地方也不需要跟太久的系统函数调用。目前是选择了SandHook作为核心ART Hook库，主要是已经提供好了Xposed API，很方便。然后是模块管理，因为没有那么多时间去弄，所以只是简单的把对应的配置文件设置成谁都能读，当然以后会优化。 未来注：本段内容没有什么营养，可以直接跳过。 编译打包自动化对，目前连自动化打包都没实现，还是手动拿dex等等然后手动压缩进去… 支持magisk安装现在只支持通过安装脚本直接修改/system，如果能够支持magisk模块式安装会少很多麻烦，比如如果变砖了只需要用mm管理器把模块给删了就好了 支持重要系统进程加载模块由于SELinux限制，目前不支持关键系统进程（如Zygote和system_server）加载模块，我这边没有什么很好的解决办法，求各位大佬赐教 :)顺便列出一些其他的限制：android 9，隐藏API访问限制，这个好办，绕过方式有很多，就不细讲了。Android 9及以上，zygote&amp;system_server还有其他系统应用会SetOnlyUseSystemOatFiles()，然后就不能加载不在/system下面的oat文件了，如果违反这个策略就会直接abort掉。android zygote fork新进程时，如果有不在白名单中的文件描述符，会进到ZygoteFailure里，然后整个进程abort掉。 配置文件加载部分因为在目标进程里加载模块肯定需要获取对应的配置，目前的做法是，把对应的配置文件设置成谁都能读，然后直接读这个文件就行，这样做当然不妥，所以计划以后去优化，比如优化成单独跑一个配置守护进程，只有这个进程能去读写配置，其他应用只能通过跨进程交互的方式拿到配置。 重新实现Xposed API目前梦境的Xposed API是SandHook自带的xposedcompat，通过DexMaker动态创建新的dex实现适配，这么做没有什么兼容性问题，但是有很大的效率问题，如果是第一次创建这个方法，需要生成dex，一套流程走下来可能就要用上100+ms。在xposedcompat_new中，有另一种实现方案：通过动态代理动态生成方法，然后把这个方法设置成native，对应的native函数也是通过libffi动态生成的，在这个native方法里跳到分发函数执行。这个方案对我来说很不错，至少不会太慢。（当然稳定性存疑） 结语目前梦境框架还有非常多的不足，目前只能当个PoC用，如果你有兴趣，不妨一起来玩 ^_^核心：Dreamland配套的管理器 Dreamland ManagerQQ群：949888394","categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://canyie.github.io/tags/android/"},{"name":"art","slug":"art","permalink":"https://canyie.github.io/tags/art/"},{"name":"xposed","slug":"xposed","permalink":"https://canyie.github.io/tags/xposed/"},{"name":"AOP","slug":"AOP","permalink":"https://canyie.github.io/tags/AOP/"},{"name":"hook","slug":"hook","permalink":"https://canyie.github.io/tags/hook/"}]},{"title":"我也有自己的个人博客啦！","slug":"hello-world","date":"2019-10-28T12:39:23.000Z","updated":"2020-04-15T03:05:17.501Z","comments":true,"path":"2019/10/28/hello-world/","link":"","permalink":"https://canyie.github.io/2019/10/28/hello-world/","excerpt":"我也有自己的个人博客啦！","text":"我也有自己的个人博客啦！ 基于GitHub Pages + Hexo，主题为Volantis本站地址：https://canyie.github.io/","categories":[],"tags":[{"name":"闲聊","slug":"闲聊","permalink":"https://canyie.github.io/tags/%E9%97%B2%E8%81%8A/"}]}],"categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://canyie.github.io/tags/android/"},{"name":"art","slug":"art","permalink":"https://canyie.github.io/tags/art/"},{"name":"dex","slug":"dex","permalink":"https://canyie.github.io/tags/dex/"},{"name":"xposed","slug":"xposed","permalink":"https://canyie.github.io/tags/xposed/"},{"name":"AOP","slug":"AOP","permalink":"https://canyie.github.io/tags/AOP/"},{"name":"hook","slug":"hook","permalink":"https://canyie.github.io/tags/hook/"},{"name":"闲聊","slug":"闲聊","permalink":"https://canyie.github.io/tags/%E9%97%B2%E8%81%8A/"}]}