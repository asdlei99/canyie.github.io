{"meta":{"title":"残页的小博客","subtitle":null,"description":"残页的小博客~","author":"残页","url":"https://canyie.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-10-30T05:21:23.744Z","updated":"2019-10-30T05:21:23.744Z","comments":true,"path":"404.html","permalink":"https://canyie.github.io/404.html","excerpt":"","text":"404 Not Found 啊哦？页面不见了呢......"},{"title":"关于","date":"2020-04-11T09:31:48.075Z","updated":"2020-04-11T09:31:48.075Z","comments":true,"path":"about/index.html","permalink":"https://canyie.github.io/about/index.html","excerpt":"","text":"本站是残页无聊搭的一个小博客，基于GitHub Pages + Hexo，主题为Volantis 关于我：一个初中生，喜欢编程，喜欢航空。我在这里：QQ聊天 GitHub 知乎 哔哩哔哩 Twitter"},{"title":"所有分类","date":"2019-10-29T04:15:51.429Z","updated":"2019-10-29T04:15:51.429Z","comments":true,"path":"categories/index.html","permalink":"https://canyie.github.io/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-04-11T09:39:31.518Z","updated":"2020-04-11T09:39:31.518Z","comments":true,"path":"friends/index.html","permalink":"https://canyie.github.io/friends/index.html","excerpt":"","text":"各位大佬想交换友链的话可以在 issue区 留言，必须要有名称、头像链接、和至少一个标签哦～ 名称： 残页的小博客头像： https://canyie.github.io/data/image/avatar.jpg网址： https://canyie.github.io/标签： Android"},{"title":"所有标签","date":"2020-04-11T09:30:07.867Z","updated":"2020-04-11T09:30:07.867Z","comments":true,"path":"tags/index.html","permalink":"https://canyie.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-10-30T03:51:51.325Z","updated":"2019-10-30T03:51:51.325Z","comments":true,"path":"data/js/search_children.js","permalink":"https://canyie.github.io/data/js/search_children.js","excerpt":"","text":"var domain='http://qzonestyle.gtimg.cn/qzone_v6/lostchild/';document.write('');document.write('');/* |xGv00|2c679710685b04aaa3216bae2b68a58c */"}],"posts":[{"title":"ART上的动态Java方法hook框架","slug":"dynamic-hooking-framework-on-art","date":"2020-04-27T02:00:00.000Z","updated":"2020-04-27T02:08:44.885Z","comments":true,"path":"2020/04/27/dynamic-hooking-framework-on-art/","link":"","permalink":"https://canyie.github.io/2020/04/27/dynamic-hooking-framework-on-art/","excerpt":"大家应该还记得我上次介绍的Dreamland吧，忘记了也没事，简单介绍一下：这是一个类似Xposed的框架，可以注入应用进程并进行方法hook。进程注入上次已经说过了，另一个重点hook当时是使用了SandHook框架，这是一款非常优秀的hook框架，但是有点问题，不太适合Dreamland；在比较了其他hook框架之后，发现似乎都存在一些问题，最终决定自己动手写一个。已经开源，代码在这：Pine，接下来我会介绍它的具体实现。","text":"大家应该还记得我上次介绍的Dreamland吧，忘记了也没事，简单介绍一下：这是一个类似Xposed的框架，可以注入应用进程并进行方法hook。进程注入上次已经说过了，另一个重点hook当时是使用了SandHook框架，这是一款非常优秀的hook框架，但是有点问题，不太适合Dreamland；在比较了其他hook框架之后，发现似乎都存在一些问题，最终决定自己动手写一个。已经开源，代码在这：Pine，接下来我会介绍它的具体实现。 其他框架的一些问题注：这里并没有贬低其他框架的意思，只是单纯的比较现在是2020年，ART Hook框架已经非常多，但是肯定不是随便拿一个就能用的；我们需要一个能提供Xposed-style hook接口的框架，Xposed的hook接口只要求提供一个callback，是完全动态的，而像YAHFA这样的框架则要求提供一个与目标方法参数与返回值都相同的方法，如果需要调用原方法还需要提供一个backup方法，无法直接做到像Xposed那样的风格的hook。这样一过滤，剩下的框架就不多了，挑出了几个框架： Whale，原理是设置目标方法为native，然后用libffi动态生成一个处理函数，设置entry_point_from_jni为这个处理函数。这个框架可以直接像Xposed那样hook，不过实测不太稳定，比如在bridge里随便抛个异常（即使被try-catch住）就会导致Runtime直接abort。Frida/AndHook似乎也是一样的套路，应该也会有这个问题。 SandHook，这个框架对Xposed兼容自带有两种方案：一是用DexMaker动态生成bridge函数，没有什么兼容性问题，但是第一次加载的时候会很慢；二是用动态代理生成bridge方法，这个bridge方法用像whale一样的方案：设置native，libffi动态生成native处理函数，设置entry_point_from_jni。这个方案用起来很快，但是存在挺多坑，稳定性存疑。 FastHook，根据调用约定在栈里捞参数，作者宣称它“高效稳定、简洁易用”，然而试了下，并不稳定，而且提供的hook接口很难用（一个通用接口有7个参数），而且作者现在似乎不维护了，emmm Epic，根据调用约定从寄存器和栈里解析参数，VirtualXposed和太极都在用，经过大量验证非常稳定，不过现在闭源了，开源版有一些bug 经过对比，发现大多数hook框架都不太符合要求，Epic现在闭源，最终决定自己动手写一个。注：这里只是根据我的需求评估的，如果你可以提供与原方法参数和返回值都相同的hook方法与backup方法，或者对稳定性有较高要求而速度是其次的话，那么更建议使用成熟的SandHook框架。 基础知识在介绍Pine之前，先介绍一下基础知识。一个方法/构造器在art中表示为一个ArtMethod对象，ArtMethod保存着该方法的信息等。以Android 9.0的源码为例，一个ArtMethod是这样的： 1234567891011121314151617class ArtMethod FINAL &#123; /** 该方法的所属类 */ GcRoot&lt;mirror::Class&gt; declaring_class_; /** 方法的访问标志，比如public，private就存储在这里 */ std::atomic&lt;std::uint32_t&gt; access_flags_; // 省略一些成员 struct PtrSizedFields &#123; /** 公共存储区域，Native方法为对应的native函数，非native方法则是其他东西（比如jit要用的ProfilingInfo） */ void* data_; /** 方法入口，如果已被编译则为编译后的代码入口，未编译则为解释器入口 */ void* entry_point_from_quick_compiled_code_; &#125;&#125; 略去一些细节，ART的函数调用过程其实很简单： caller想办法拿到callee的ArtMethod对象 将参数按照约定存到寄存器和栈里 跳转到callee的方法入口 基本实现Pine支持两种方案，一种是替换入口，即修改ArtMethod的entrypoint；另一种类似于native的inline hook，即覆盖掉目标方法的代码开始处的一段代码，用于弥补Android 8.0以下版本入口替换很有可能不生效的问题。 入口替换我们看看上面的ArtMethod，发现了一个很重要的成员：entry_point_from_quick_compiled_code_，这个变量保存至该方法的代码入口，如果我们直接修改这个变量，不就可以达到hook的目的了吗？然而事情并没有这么简单。用入口替换方案去hook自己的方法，大部分情况下是没有问题的；但如果你需要hook系统的方法，并且这个方法不是virtual方法（比如TextView.setText(CharSequence)），那么很有可能不生效。这是因为，Android 8.0以下，art有一个Sharpening优化，如果art能够确定callee的代码入口，那么有可能直接把入口硬编码在机器码内，根本不会去ArtMethod里取入口。 还有没有其他方法呢？当然有，那就是inline hook。 inline hook从上面的分析可以看出，目标方法的代码是一定会用到的；那么我们可以直接修改目标方法的代码，把前几条代码修改为一段跳转指令，这样当这个方法执行时，就会直接跳到我们指定的另一段代码处执行，我们就达到了hook目的。以下情况不能被inline hook： jni方法和代理方法。jni方法和代理方法都没有对应的已编译代码，其entry_point_from_quick_compiled_code_固定指向一段trampoline，这个trampoline会跳转到真正的代码处执行。 方法未被编译且尝试编译失败。 方法已被编译，但代码太短以至于一个简单的跳转指令都放不下。跳转指令arm32需要8字节，arm64需要16字节；实际上我们可以考虑其他方式跳转，比如如果我们可以偷到目标代码附近的内存，就能直接使用b指令跳转（此方法来自于Dobby框架）；或者我们可以放一个非法指令，程序执行到这条指令时会产生一个SIGILL信号，我们捕获到这个信号，对寄存器和栈进行操作就能直接控制执行流程（注：此方法来自于卓桐大佬的Android elf hook的方式）。之所以不做这个处理，是因为这样的方法很少，而且很可能被直接内联到caller里，个人认为没必要。 方法的前几条代码里有pc寄存器相关指令，hook时没问题，但执行原方法时会有问题（具体见后面的 一些问题-执行原方法 部分） 当出现以上情况时，自动转用入口替换模式。 四个跳板我们需要写四段模板代码，注意要用纯汇编写以避免破坏栈和寄存器，暂时命名为trampoline： DirectJumpTrampoline：inline hook使用，功能是跳转至一个绝对地址，需要插入目标方法的代码开始处。 BridgeJumpTrampoline：两个方案都需要使用，处理一些东西并跳转至Bridge方法，这个bridge是我们预先写好的一个java方法，跳转到这个方法之后我们就回到了java世界，然后就可以开始处理真实的AOP逻辑。 CallOriginTrampoline：入口替换使用，功能是设置r0寄存器为原方法并跳转至原方法入口。将成为backup方法的入口。（暂未使用，目前发现设置r0寄存器为原方法后有几率造成卡死） BackupTrampoline：inline hook使用，设置r0寄存器为原方法、存放被覆盖的代码并跳转至(原方法入口+备份代码大小)处继续执行。将成为backup方法的入口。（其实这段代码叫trampoline是不太合适的） 一些问题基本原理比较简单，但是实现的过程中会遇到很多的问题，这里简单说一下。 参数解析大概想了一下，参数解析有以下方案： 动态生成出一个有和原方法相同的参数列表的方法，这个方法只是一个bridge，作用就是传递参数和返回值；需要注意的是，这个方法必须要有对应的代码，和一些必要的成员，为此可以有两种方法： 通过如DexMaker等动态字节码生成技术动态生成出这个方法（EdXposed用的方案）；这种方案的主要问题是比较慢，动态生成dex并加载是耗时操作。 利用java的动态代理动态生成，难点在于如何控制这个新生成的代理方法做你想要做的事；SandHook的xposedcompat_new里实现了一个：把这个代理方法设置为native方法，然后通过libffi动态生成对应的native函数，然后修改其entry_point_from_jni（其实就是Whale那个方案，不过whale是对目标方法，SandHook的xposedcompat_new是对处理方法），这个方案有点问题，凭空把一个非native方法变为native有很多未知的坑等着你去踩。 统一bridge方法，在这个bridge方法里自己解析参数。 art为了实现java的动态代理，自己就有一个art_quick_proxy_invoke_handler，如果能利用好这个内置函数，那么就可以达到目的。不过看了下代码，这个函数利用起来很难，暂时先放弃。 最终我选择自己解析参数，hook时较快；为此我们需要了解ART的函数调用约定，根据这个约定去解析。以arm32/thumb2为例，在ART中，r0寄存器固定保存callee的ArtMethod*，r1~r3寄存器保存前三个参数（注：非静态方法实际上第一个参数就是this）；同时，sp~sp+12上也传递着r0~r3上的值；多余的参数通过栈传递，比如第四个参数就存在sp+16上；如果一个参数一个寄存器放不下（long/double），那么会占用两个寄存器。不过这只是基本情况，其他情况还需特别处理（如在6.0或以上，如果第一个参数是long/double类型的，那么会跳过r1寄存器等等）。ok，我们发现了一个简单的办法：我们可以修改r1~r3传递其他东西，必须需要的只有sp，因为sp~sp+12上也存放着r0~r3上的值，剩下的参数也通过sp传递，那么我们直接通过sp就能获取到所有参数？兴冲冲的写好代码测试发现，此路不通，通过sp拿到的前几个参数是乱的。为什么？weishu的文章论ART上运行时 Method AOP实现里揭露了答案： 虚拟机本身也是知道 sp + 12 这段空间相当于是浪费的，因此他直接把这段空间当做类似寄存器使用了。 那怎么办呢？在栈上分配内存来放？同样行不通，这样一旦发生栈回溯，sp被修改的那一帧会因为回溯不到对应的函数引发致命错误，导致runtime abort。现在我采用和epic类似的方法实现：在hook时分配一段内存，这段内存用来放r0~r3，先保存了再跳转到bridge方法，bridge方法就可以取出对应的值。另外对象类型要特别处理，art传递对象时其实传的是这个对象的地址，我们接收到的只是一串数字，转换的方法有两个： 直接通过java层的Unsafe，直接put进地址，拿出来的就是对象 通过jni，用一个art内部函数把地址转换成jobject，返回到java的时候会自动进行转换 这里我选择第二种方法，因为第一种需要用反射调用Unsafe，而反射效率不是很高，有较多参数时效率会比较低。 多线程并发上面提到由于没有其他地方放前几个参数，所以在hook时就会提前分配一块地址专门来放，大概这样： 1234ldr ip, extra_addrstr r1, [ip, #0]str r2, [ip, #4]str r3, [ip, #8] 然后会在bridge里拿到r1~r3。这段代码在单线程下执行并没有问题，但在多线程环境下，如果存值之后还没来得及取值就被其他线程修改，就会读到错误的值，导致错误。修复这个问题的一种方法是禁止多线程并发执行，比如给目标方法加上synchronized的flag，但是这样显然太重了，我们只需要在存值——取值这段时间里禁止并发即可。为此，我通过CAS机制写了一个自旋锁： 123456789acquire_lock:ldrex r0, [ip]cmp r0, #0wfene // other thread holding the lock, wait it release lockmov r0, #1strexeq r0, r0, [ip]cmpeq r0, #0 // store succeeded?bne acquire_lock // acquire lock failed, try againdmb extras的第一个变量即为锁标志，为0代表无锁，为1代表已有线程持有该锁，获取时通过CAS去抢锁，bridge里将锁标志置0释放锁。注意需要添加内存屏障以阻止部分关键指令被乱序执行引发错误。这里还有一个问题：arm32/thumb2下，ldrex/strex需要一个寄存器来接收结果，而ip寄存器已存放着extras的地址；arm64下stlxr要求source和status不能相同等等，都需要占用一个额外寄存器，这里我选择r0寄存器，原因很简单：r0寄存器固定保存callee的ArtMethod指针，这个值在hook的时候就已确定；跳转到bridge方法时也会更改为bridge的ArtMethod等。（注：发现arm64有一个xzr/wzr寄存器固定为0，如果把lock_flag改成0为有锁1为无锁就可以直接用wzr寄存器了，可以少用一个寄存器，列入TODO列表里了）（注2：仔细思考了一下，发现如果两个线程抢锁，持有锁的线程获取到锁以后还没来得及释放就因为gc等进入checkpoint被挂起，而另一个线程在等锁无法进入checkpoint，导致类似死锁的情况，最终导致挂起所有线程超时runtime abort，没想到怎么解决，暂时先挂着吧） 执行原方法要执行原方法，我们需要一个原方法代码入口。入口替换模式下，直接使用原来那个入口就行；但在inline hook模式下，由于我们修改了方法入口处的代码，需要对原方法代码进行备份，调用原方法的时候直接执行这段备份的代码，然后继续跳转到剩余代码部分执行即可。我们特别写了一段叫做BackupTrampoline的代码实现，以arm32为例： 12345678910FUNCTION(pine_backup_trampoline)ldr r0, pine_backup_trampoline_origin_method // 将r0寄存器设置为原方法VAR(pine_backup_trampoline_override_space).long 0 // 会被替换为真实代码.long 0 // 会被替换为真实代码ldr pc, pine_backup_trampoline_remaining_code_entry // 跳转到剩余部分继续执行VAR(pine_backup_trampoline_origin_method).long 0VAR(pine_backup_trampoline_remaining_code_entry).long 0 而thumb2需要特别注意，由于在thumb2下一条指令可能是4字节也可能是2字节，如果我们固定为只备份8字节则有可能导致指令被截断（比如4-2-4），所以备份的时候一定要注意指令完整性。 123static inline bool IsThumb32(uint16_t inst) &#123; return ((inst &amp; 0xF000) == 0xF000) || ((inst &amp; 0xF800) == 0xE800);&#125; 1234567891011FUNCTION(pine_thumb_backup_trampoline)ldr r0, pine_thumb_backup_trampoline_origin_methodVAR(pine_thumb_backup_trampoline_override_space).long 0 // 会被替换为真实代码.long 0 // 会被替换为真实代码nop // 可能会被替换为真实代码，否则只是一条nopldr pc, pine_thumb_backup_trampoline_remaining_code_entry // 跳转到剩余部分继续执行VAR(pine_thumb_backup_trampoline_origin_method).long 0VAR(pine_thumb_backup_trampoline_remaining_code_entry).long 0 另一个问题是，在inline hook模式下，我们需要把部分原始指令备份到另一个地方，如果这部分指令里有pc相关指令，由于此时指令地址不同，会发生错误。传统native inline hook框架的做法是做指令修复，而因为art上这种情况很少，所以Pine目前并没有指令修复，只是简单的做判断，如果发现这种情况直接转用入口替换模式。（注：其实还可以有另一种方案，就是不用原来的指令，设置r0寄存器为原方法后直接跳转到art_quick_to_interpreter_bridge走解释执行就行，注意需要清掉对应ProfilingInfo的saved_entry_point_，否则可能会直接跳转到原方法入口执行，就死循环了） 好的，现在我们有了原代码入口，我们可以动态创建出一个backup方法，设置backup方法入口为原代码入口，然后直接反射调用这个方法就行了！不过有一点要注意，由于这个方法是动态创建出来的，而ArtMethod的declaring_class是GcRoot，可能被gc移动，art会自动更新原版ArtMethod里的地址，但是不会更新我们自己创建的ArtMethod里的地址，所以需要我们自己主动更新。 123456789void Pine_updateDeclaringClass(JNIEnv *env, jclass, jobject javaOrigin, jobject javaBackup) &#123; auto origin = art::ArtMethod::FromReflectedMethod(env, javaOrigin); auto backup = art::ArtMethod::FromReflectedMethod(env, javaBackup); uint32_t declaring_class = origin-&gt;GetDeclaringClass(); if (declaring_class != backup-&gt;GetDeclaringClass()) &#123; LOGI(\"The declaring_class of method has moved by gc, update its reference in backup method now!\"); backup-&gt;SetDeclaringClass(declaring_class); &#125;&#125; 不过还有一个问题，假如在我们检查完declaring_class之后调用backup之前发生gc，这个class对象被移动了，怎么办呢？难道要在这段时间里直接关闭Moving GC？太重了，我们只希望declaring_class不会被移动就行。实际上，确实有让一个对象暂时不会被移动的方法：对于在栈上有引用的对象，不会被gc移动。那就简单了，保证对应的Class对象在栈上有引用即可，需要注意必须显式使用一下，否则会被优化： 12345678Class&lt;?&gt; declaring = origin.getDeclaringClass();updateDeclaringClass(origin, backup);Object result = backup.invoke(thisObject, args);// Explicit use declaring_class object to ensure it has reference on stack// and avoid being moved by gc.declaring.getClass();return result; （注：这里之前是考虑过用FastHook的那种方案的，即动态代理创建出forward方法，只修改forward的entry而非全部备份，不过试下来发现有点问题）ok，调用原方法完成。 jit 这是官方文档上的JIT工作流程图。Pine对jit的处理和其他框架差不多： 如果目标方法没被编译，先尝试调用jit_compile_method进行编译，编译的结果直接影响到走inline hook还是入口替换； jit编译会改变线程状态，有可能会造成crash，所以编译完后需要恢复线程状态； 给原方法和backup方法添加kAccCompileDontBother防止其被jit编译从而引发错误； 另外还照着SandHook写了一个禁用jit inline。 不过这似乎还远远不够。FastHook作者在这篇文章中提到了这两点： 如果该方法正在jit编译，那么我们手动编译是不安全的。 jit gc会修改方法入口为解释器入口，当方法进入解释器时会重新设置为原来的入口并跳转到原来的入口执行。 另外我简单看了下jit源码，发现包括ProfilingInfo和被编译的代码在内的大部分内容都有可能被回收。暂时还没想好这个怎么处理emmm ELF符号解析受限于实现原理，我们需要获得来自系统私有库内的大量私有符号，最简单的办法就是用dlsym，不过在Android N上，Google禁止了这种行为，而且我们还需要获取一些在.symtab表里的符号（比如art_quick_to_interpreter_bridge），这些用dlsym是搜索不到的。因为我对elf格式不熟，所以直接用的SandHook作者的AndroidELF，在这特别表示感谢~ 各设备兼容处理安卓各版本的变化这些都是老生常谈了，这条要讲的问题是指当厂商修改了一些成员偏移的情况。比如ArtMethod，我们做hook至少需要获得art_entry_point_from_quick_compiled_code_和access_flags_，我们可以根据AOSP写死偏移，但是这样的话一旦厂商做了什么手脚改了偏移，那就完蛋了。而我知道的框架只有SandHook和Whale是动态查找偏移，其他都是根据AOSP写死偏移。实际上我们可以在运行时动态获得这些offset，拿access_flags_来说吧，我们可以定义一个方法，然后根据该方法的属性预测access_flag，然后可以用这个预测的flag在ArtMethod里动态搜索到值（这个方法最好是native的，否则很有可能会被加上一个kAccSkipAccessChecks导致搜索不到）；而对于entry_point_from_quick_compiled_code_，并没有办法预测值，但是我们可以预测在art_entry_point_from_quick_compiled_code_旁边的data_成员的值：对于native方法，这个值是对应的jni函数地址，我们可以搜索到，然后直接加上成员大小就行（需要注意内存对齐）而对于无法动态获得偏移的情况，比如CompilerOptions，它在内存中是这样的： 12345678910class CompilerOptions final &#123; CompilerFilter::Filter compiler_filter_; size_t huge_method_threshold_; size_t large_method_threshold_; size_t small_method_threshold_; size_t tiny_method_threshold_; size_t num_dex_methods_threshold_; size_t inline_max_code_units_; // 省略一大堆成员&#125; 假如我们要修改它的inline_max_code_units_，没什么能很好获取偏移的办法，那么我们只能根据版本写死偏移，运行时就只能判断对应的值是否在范围内，超过范围不修改（比如获取出一个114514，那肯定不是正常的值，就可以判断出偏移不对）。 使用上面说了这么久实现原理，下面让我们来看看这东西怎么用吧~ 基础使用在bridge.gradle里加入如下依赖： 123dependencies &#123; implementation 'top.canyie.pine:core:0.0.1'&#125; 配置一些基本信息： 12PineConfig.debug = true; // 是否debug，true会输出较详细logPineConfig.debuggable = BuildConfig.DEBUG; // 该应用是否可调试，建议和配置文件中的值保持一致，否则会出现问题 然后就可以开始使用了。 例子1：监控Activity onCreate（注：仅做测试使用，如果你真的有这个需求更建议使用registerActivityLifecycleCallbacks()等接口） 123456789Pine.hook(Activity.class.getDeclaredMethod(\"onCreate\", Bundle.class), new MethodHook() &#123; @Override public void beforeHookedMethod(Pine.CallFrame callFrame) &#123; Log.i(TAG, \"Before \" + callFrame.thisObject + \" onCreate()\"); &#125; @Override public void afterHookedMethod(Pine.CallFrame callFrame) &#123; Log.i(TAG, \"After \" + callFrame.thisObject + \" onCreate()\"); &#125;&#125;); Pine.CallFrame就相当于xposed的MethodHookParams。 例子2：拦截所有java线程的创建与销毁： 123456789101112131415final MethodHook runHook = new MethodHook() &#123; @Override public void beforeHookedMethod(Pine.CallFrame callFrame) throws Throwable &#123; Log.i(TAG, \"Thread \" + callFrame.thisObject + \" started...\"); &#125; @Override public void afterHookedMethod(Pine.CallFrame callFrame) throws Throwable &#123; Log.i(TAG, \"Thread \" + callFrame.thisObject + \" exit...\"); &#125;&#125;;Pine.hook(Thread.class.getDeclaredMethod(\"start\"), new MethodHook() &#123; @Override public void beforeHookedMethod(Pine.CallFrame callFrame) &#123; Pine.hook(ReflectionHelper.getMethod(callFrame.thisObject.getClass(), \"run\"), runHook); &#125;&#125;); 注意如果我们只hook Thread.run()，Thread子类可能会重写Thread.run()方法不调用super.run()那么就无法hook到，所以我们可以hook一定会被调用的Thread.start()方法感知到新线程建立，此时可以获得具体的类，然后直接hook这些运行时才被发现的类就行。 我们还可以玩点丧心病狂的，比如： 12Method checkThread = Class.forName(\"android.view.ViewRootImpl\").getDeclaredMethod(\"checkThread\");Pine.hook(checkThread, MethodReplacement.DO_NOTHING); 这段代码会干什么呢？没错，现在你可以在任何线程随意操作ui了，不用怕ViewRootImpl.CalledFromWrongThreadException了 ^_^当然，Pine的用途远不止这些，这一切都取决于您的想象力~ 其他一些API这里介绍一些其他的API： Pine.ensureInitialized()：默认情况下Pine是懒初始化的，即第一次调用需要初始化的API时才会进行初始化，你可以调用此方法来主动进行初始化 Pine.invokeOriginalMethod(Member method, Object thisObject, Object... args)：调用原方法，不过不建议使用这个接口，更建议使用效率更高的CallFrame.invokeOriginalMethod()。 Pine.setHookMode(int hookMode)：设置Pine的hook方案，取值：Pine.HookMode.AUTO：由Pine自行决定；Pine.HookMode.INLINE：inline hook优先；Pine.HookMode.REPLACEMENT：入口替换优先。注：设置hook方案并不代表Pine一定会以该方案进行hook，如hook jni函数就只能进行入口替换。 Pine.disableJitInline()：尝试关闭JIT的内联优化。 Pine.compile(Member method)：主动调用JIT尝试编译一个方法。 Pine.decompile(Member method, boolean disableJit)：使某个方法转换为解释执行。参数disableJit表示是否需要阻止该方法再次被JIT编译。 还有其他一些不太常用的就不再介绍了，感兴趣的可以去看看源码。 使用须知 Pine的开源协议是反996协议。 Pine支持Android 4.4（只支持ART）~10.0，aarch32（未测试，几乎见不到，以后可能会移除）/thumb2/arm64架构；6.0 32bit下参数解析可能会有问题，没有对应测试机无法测试（其实是看epic源码有对M进行特殊处理，不过这段没看懂emm）；另外，Pine没有自带绕过隐藏API限制策略的方法，如果你需要在9.0及以上使用，那么请自行处理（比如使用FreeReflection）；R上简单看了下，jmethodID有可能不是真实的ArtMethod*了，不过java层Executable的artMethod变量似乎还是，处理了这点应该就行 Pine只在少数的几台设备上做过测试，稳定性暂无法保证，不建议在生产环境中使用。 大部分java方法都可被Pine hook，但是这些方法除外： 类的静态初始化块 部分关键系统方法 被Pine内部使用了的方法（hook会导致死循环） 有无法被inline hook的情况 被完全内联的方法（如果能知道caller，那么可以decompile caller） 总结嗯，大概就是这样啦~再放一下开源地址：Pine几个对我帮助比较大的项目： SandHook Epic AndroidELF：本项目使用了的ELF符号搜索库 YAHFA FastHook 在这再次表示感谢~ 如果你对本项目感兴趣的话，可以拿出你的手机帮我测试一下，欢迎提issue和PR，也可以加一下QQ群：949888394一起讨论，^_^","categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://canyie.github.io/tags/android/"},{"name":"art","slug":"art","permalink":"https://canyie.github.io/tags/art/"},{"name":"AOP","slug":"AOP","permalink":"https://canyie.github.io/tags/AOP/"},{"name":"hook","slug":"hook","permalink":"https://canyie.github.io/tags/hook/"},{"name":"xposed","slug":"xposed","permalink":"https://canyie.github.io/tags/xposed/"}]},{"title":"一种在ART上快速加载dex的方法","slug":"fast-load-dex-on-art-runtime","date":"2020-02-15T02:02:33.000Z","updated":"2020-04-15T03:08:44.350Z","comments":true,"path":"2020/02/15/fast-load-dex-on-art-runtime/","link":"","permalink":"https://canyie.github.io/2020/02/15/fast-load-dex-on-art-runtime/","excerpt":"在国内的大环境下，Android上插件化/热修复等技术百花齐放，而这一切都基于代码的动态加载。Android提供了一个DexClassLoader。用这个API能成功加载dex，但有一个比较严重的问题：Android Q以下，当这个dex被加载时，如果没有已经生成的oat，则会执行一次dex2oat把这个dex编译为oat，导致第一次加载dex会非常非常慢。个人认为这样的设计是非常不合理的，虽然转换成oat之后执行会很快，但完全可以让用户以解释器模式先愉快的用着，dex2oat放另一个线程执行多好。Android 8.0上谷歌还提供了一个InMemoryDexClassLoader，而以前的Android版本，就要开发者自己想办法了……","text":"在国内的大环境下，Android上插件化/热修复等技术百花齐放，而这一切都基于代码的动态加载。Android提供了一个DexClassLoader。用这个API能成功加载dex，但有一个比较严重的问题：Android Q以下，当这个dex被加载时，如果没有已经生成的oat，则会执行一次dex2oat把这个dex编译为oat，导致第一次加载dex会非常非常慢。个人认为这样的设计是非常不合理的，虽然转换成oat之后执行会很快，但完全可以让用户以解释器模式先愉快的用着，dex2oat放另一个线程执行多好。Android 8.0上谷歌还提供了一个InMemoryDexClassLoader，而以前的Android版本，就要开发者自己想办法了…… 源码分析注：为了说明此方法能在较低版本的ART上运行，本文分析的源码是Android 5.0的源码，之后的Android版本里OpenDexFileFromOat方法搬到了OatFileManager里，而调用dex2oat的部分则重构到了OatFileAssistant中，大致逻辑相同，感兴趣的可以自己去看看；至于Android 4.4，简单扫了一下源码似乎是生成oat失败就会直接抛一个IOException拒绝加载，emmm…… 我们在Java代码里用new DexClassLoader()的方式加载dex，最后会调用到DexFile.openDexFileNative中，这个函数的实现是这样的： 12345678910111213141516171819202122232425static jlong DexFile_openDexFileNative(JNIEnv* env, jclass, jstring javaSourceName, jstring javaOutputName, jint) &#123; ScopedUtfChars sourceName(env, javaSourceName); if (sourceName.c_str() == NULL) &#123; return 0; &#125; NullableScopedUtfChars outputName(env, javaOutputName); if (env-&gt;ExceptionCheck()) &#123; return 0; &#125; ClassLinker* linker = Runtime::Current()-&gt;GetClassLinker(); std::unique_ptr&lt;std::vector&lt;const DexFile*&gt;&gt; dex_files(new std::vector&lt;const DexFile*&gt;()); std::vector&lt;std::string&gt; error_msgs; bool success = linker-&gt;OpenDexFilesFromOat(sourceName.c_str(), outputName.c_str(), &amp;error_msgs, dex_files.get()); if (success || !dex_files-&gt;empty()) &#123; // In the case of non-success, we have not found or could not generate the oat file. // But we may still have found a dex file that we can use. return static_cast&lt;jlong&gt;(reinterpret_cast&lt;uintptr_t&gt;(dex_files.release())); &#125; else &#123; // 加载失败的情况，省略 &#125;&#125; 这里的注释很有意思，如果返回false（生成oat失败），但是有被成功加载的dex，那么还是应该当做成功。可以看出具体实现在ClassLinker中的OpenDexFilesFromOat里，我们点进去看看： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117// Multidex files make it possible that some, but not all, dex files can be broken/outdated. This// complicates the loading process, as we should not use an iterative loading process, because that// would register the oat file and dex files that come before the broken one. Instead, check all// multidex ahead of time.bool ClassLinker::OpenDexFilesFromOat(const char* dex_location, const char* oat_location, std::vector&lt;std::string&gt;* error_msgs, std::vector&lt;const DexFile*&gt;* dex_files) &#123; // 1) Check whether we have an open oat file. // This requires a dex checksum, use the \"primary\" one. bool needs_registering = false; const OatFile::OatDexFile* oat_dex_file = FindOpenedOatDexFile(oat_location, dex_location, dex_location_checksum_pointer); std::unique_ptr&lt;const OatFile&gt; open_oat_file( oat_dex_file != nullptr ? oat_dex_file-&gt;GetOatFile() : nullptr); // 2) If we do not have an open one, maybe there's one on disk already. // In case the oat file is not open, we play a locking game here so // that if two different processes race to load and register or generate // (or worse, one tries to open a partial generated file) we will be okay. // This is actually common with apps that use DexClassLoader to work // around the dex method reference limit and that have a background // service running in a separate process. ScopedFlock scoped_flock; if (open_oat_file.get() == nullptr) &#123; if (oat_location != nullptr) &#123; std::string error_msg; // We are loading or creating one in the future. Time to set up the file lock. if (!scoped_flock.Init(oat_location, &amp;error_msg)) &#123; error_msgs-&gt;push_back(error_msg); return false; &#125; // TODO Caller specifically asks for this oat_location. We should honor it. Probably? open_oat_file.reset(FindOatFileInOatLocationForDexFile(dex_location, dex_location_checksum, oat_location, &amp;error_msg)); if (open_oat_file.get() == nullptr) &#123; std::string compound_msg = StringPrintf(\"Failed to find dex file '%s' in oat location '%s': %s\", dex_location, oat_location, error_msg.c_str()); VLOG(class_linker) &lt;&lt; compound_msg; error_msgs-&gt;push_back(compound_msg); &#125; &#125; else &#123; // TODO: What to lock here? bool obsolete_file_cleanup_failed; open_oat_file.reset(FindOatFileContainingDexFileFromDexLocation(dex_location, dex_location_checksum_pointer, kRuntimeISA, error_msgs, &amp;obsolete_file_cleanup_failed)); // There's no point in going forward and eventually try to regenerate the // file if we couldn't remove the obsolete one. Mostly likely we will fail // with the same error when trying to write the new file. // TODO: should we maybe do this only when we get permission issues? (i.e. EACCESS). if (obsolete_file_cleanup_failed) &#123; return false; &#125; &#125; needs_registering = true; &#125; // 3) If we have an oat file, check all contained multidex files for our dex_location. // Note: LoadMultiDexFilesFromOatFile will check for nullptr in the first argument. bool success = LoadMultiDexFilesFromOatFile(open_oat_file.get(), dex_location, dex_location_checksum_pointer, false, error_msgs, dex_files); if (success) &#123; // 我们没有有效的oat文件，所以不会走到这里 &#125; else &#123; if (needs_registering) &#123; // We opened it, delete it. open_oat_file.reset(); &#125; else &#123; open_oat_file.release(); // Do not delete open oat files. &#125; &#125; // 4) If it's not the case (either no oat file or mismatches), regenerate and load. // Look in cache location if no oat_location is given. std::string cache_location; if (oat_location == nullptr) &#123; // Use the dalvik cache. const std::string dalvik_cache(GetDalvikCacheOrDie(GetInstructionSetString(kRuntimeISA))); cache_location = GetDalvikCacheFilenameOrDie(dex_location, dalvik_cache.c_str()); oat_location = cache_location.c_str(); &#125; bool has_flock = true; // Definitely need to lock now. if (!scoped_flock.HasFile()) &#123; std::string error_msg; if (!scoped_flock.Init(oat_location, &amp;error_msg)) &#123; error_msgs-&gt;push_back(error_msg); has_flock = false; &#125; &#125; if (Runtime::Current()-&gt;IsDex2OatEnabled() &amp;&amp; has_flock &amp;&amp; scoped_flock.HasFile()) &#123; // Create the oat file. open_oat_file.reset(CreateOatFileForDexLocation(dex_location, scoped_flock.GetFile()-&gt;Fd(), oat_location, error_msgs)); &#125; // Failed, bail. if (open_oat_file.get() == nullptr) &#123; // 如果无法生成oat，那么直接加载dex std::string error_msg; // dex2oat was disabled or crashed. Add the dex file in the list of dex_files to make progress. DexFile::Open(dex_location, dex_location, &amp;error_msg, dex_files); error_msgs-&gt;push_back(error_msg); return false; &#125; // 再次尝试加载oat，无关，省略&#125; 这个函数比较长，所以做了一点精简。我们在这里看到了一点端倪，这个函数做了这些事情： 检查我们是否已经有一个打开了的oat 如果没有，那么检查oat缓存目录（创建DexClassLoader时传入的第二个参数）是否已经有了一个oat，并且检查这个oat的有效性 如果没有或者这个oat是无效的，那么生成一个oat文件 我们首次加载dex时，肯定没有有效的oat，最后会生成一个新的oat： 12345if (Runtime::Current()-&gt;IsDex2OatEnabled() &amp;&amp; has_flock &amp;&amp; scoped_flock.HasFile()) &#123; // Create the oat file. open_oat_file.reset(CreateOatFileForDexLocation(dex_location, scoped_flock.GetFile()-&gt;Fd(), oat_location, error_msgs));&#125; 这里有一个if判断，直接决定是否进行dex2oat，我们看看能不能通过各种手段让这个判断不成立。 禁用dex2oat第一招：修改Runtime中的变量这个if判断里，第一个条件就是Runtime::Current()-&gt;IsDex2OatEnabled()，如果返回false，那么就不会生成oat。这个函数的实现如下： 1234567bool IsDex2OatEnabled() const &#123; return dex2oat_enabled_ &amp;&amp; IsImageDex2OatEnabled();&#125;bool IsImageDex2OatEnabled() const &#123; return image_dex2oat_enabled_;&#125; dex2oat_enabled_与image_dex2oat_enabled_都是Runtime对象中的成员变量，而Runtime可以通过JavaVM获取，所以我们只需要修改这个值就能禁用dex2oat。已经有其他人实现了这一步，具体可以看看这篇博客。然而事情真的会这么简单吗？查看源码发现Runtime是一个炒鸡大的结构体，Android里有什么东西都往这扔，你几乎可以从Runtime对象上直接或间接获取到任何东西，然而也正是因为Runtime太大了，使得没有什么好的办法获取里面的值。 让我们看看还有没有其他方法： 第二招：使用PathClassLoader我们可以看见，在if判断里，还有两个条件：has_flock和scoped_flock.HasFile()，让我们看看是否可以让这两个条件不成立。has_flock的赋值： 123456789bool has_flock = true;// Definitely need to lock now.if (!scoped_flock.HasFile()) &#123; std::string error_msg; if (!scoped_flock.Init(oat_location, &amp;error_msg)) &#123; error_msgs-&gt;push_back(error_msg); has_flock = false; &#125;&#125; 又是scoped_flock，看看在上面scoped_flock可能在哪里被初始化： 12345678910111213ScopedFlock scoped_flock;if (open_oat_file.get() == nullptr) &#123; if (oat_location != nullptr) &#123; std::string error_msg; // We are loading or creating one in the future. Time to set up the file lock. if (!scoped_flock.Init(oat_location, &amp;error_msg)) &#123; error_msgs-&gt;push_back(error_msg); return false; &#125; // 省略代码 &#125;&#125; 看看ScopedFlock的Init方法： 12345678910bool ScopedFlock::Init(const char* filename, std::string* error_msg) &#123; while (true) &#123; file_.reset(OS::OpenFileWithFlags(filename, O_CREAT | O_RDWR)); if (file_.get() == NULL) &#123; *error_msg = StringPrintf(\"Failed to open file '%s': %s\", filename, strerror(errno)); return false; &#125; // 省略一大堆代码…… &#125;&#125; 可以看见，会打开这个文件，flags为O_CREAT | O_RDWR，那我们只需要设置oat_location为不可写的路径，就能让ScopedFlock::Init返回false。不过我们要注意的是，如果oat_location不为null并且无法使用，那在上面的一个判断里就会直接返回false。怎么办？ 是时候请出我们的主角PathClassLoader了！ PathClassLoader作为DexClassLoader的兄弟（也可能是姐妹？），受到的待遇与DexClassLoader截然不同：网上讲解动态加载dex的文章几乎都只讲DexClassLoader，而对于PathClassLoader则是一笔带过：“PathClassLoader只能加载系统中已经安装过的apk”。然而事实真的是这样吗？或许Android 5.0以前是，但Android 5.0时就已经可以加载外部dex了，今天我要为PathClassLoader正名！让我们来对比一下DexClassLoader和PathClassLoader的源码。DexClassLoader： 123456public class DexClassLoader extends BaseDexClassLoader &#123; public DexClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent) &#123; super(dexPath, new File(optimizedDirectory), libraryPath, parent); &#125;&#125; 对，你没看错，有效代码就这么点。让我们再看看PathClassLoader的源码： 12345678910public class PathClassLoader extends BaseDexClassLoader &#123; public PathClassLoader(String dexPath, ClassLoader parent) &#123; super(dexPath, null, null, parent); &#125; public PathClassLoader(String dexPath, String libraryPath, ClassLoader parent) &#123; super(dexPath, null, libraryPath, parent); &#125;&#125; 实际上所以实现代码都在BaseDexClassLoader中，DexClassLoader和PathClassLoader都调用了同一个构造函数： 123456789public class BaseDexClassLoader extends ClassLoader &#123; private final DexPathList pathList; public BaseDexClassLoader(String dexPath, File optimizedDirectory, String libraryPath, ClassLoader parent) &#123; super(parent); this.pathList = new DexPathList(this, dexPath, libraryPath, optimizedDirectory); &#125;&#125; 注意第二个参数，optimizedDirectory，DexClassLoader传入的是new File(optimizedDirectory)，而PathClassLoader传入的是null。记住这一点。这两种情况最后都会调用到DexFile.openDexFileNative中 1private static native long openDexFileNative(String sourceName, String outputName, int flags); 如果是PathClassLoader，outputName为null，会进入这个if分支中： 12345678// Look in cache location if no oat_location is given.std::string cache_location;if (oat_location == nullptr) &#123; // Use the dalvik cache. const std::string dalvik_cache(GetDalvikCacheOrDie(GetInstructionSetString(kRuntimeISA))); cache_location = GetDalvikCacheFilenameOrDie(dex_location, dalvik_cache.c_str()); oat_location = cache_location.c_str();&#125; 这里会把oat_location设置成/data/dalvik-cache/下的路径，接下来因为我们根本没有对dalvik-cache的写入权限，所以无法打开fd，然后就会走到这里直接加载原始dex： 1234567if (open_oat_file.get() == nullptr) &#123; std::string error_msg; // dex2oat was disabled or crashed. Add the dex file in the list of dex_files to make progress. DexFile::Open(dex_location, dex_location, &amp;error_msg, dex_files); error_msgs-&gt;push_back(error_msg); return false;&#125; 至此整个逻辑已经明朗，通过PathClassLoader加载会把oat输出路径设置成/data/dalvik-cache/下，然后因为我们没有对dalvik-cache的写入权限，所以无法打开fd，之后会直接加载原始dex，不会进行dex2oat。（注：本文分析源码是Android 5.0，在Android 8.1时源码有改动，就算是DexClassLoader也会把optimizedDirectory设置成null，输出的oat在dex的父目录/oat/下，所以无法通过PathClassLoader快速加载dex，但在8.1时已经有InMemoryDexClassLoader了，直接通过InMemoryDexClassLoader加载就好了。 简单做了个小测试，在我的AVD（Android 7.1.1）上，用DexClassLoader加载75M的qq apk用了近80秒，并生成了一个313M的oat，而PathClassLoader用时稳定在2秒左右，emmm…… 看起来我们已经有一个比较好的办法禁用dex2oat了，不过需要修改源码没法直接全局禁用，修改Runtime风险又太大，让我们看看还有没有其他方法。 第三招：hook execv到了这里，上面那个判断肯定会成立了，似乎进行dex2oat已成定局？我们继续看CreateOatFileForDexLocation。 1234567891011121314151617181920212223const OatFile* ClassLinker::CreateOatFileForDexLocation(const char* dex_location, int fd, const char* oat_location, std::vector&lt;std::string&gt;* error_msgs) &#123; // Generate the output oat file for the dex file VLOG(class_linker) &lt;&lt; \"Generating oat file \" &lt;&lt; oat_location &lt;&lt; \" for \" &lt;&lt; dex_location; std::string error_msg; if (!GenerateOatFile(dex_location, fd, oat_location, &amp;error_msg)) &#123; CHECK(!error_msg.empty()); error_msgs-&gt;push_back(error_msg); return nullptr; &#125; std::unique_ptr&lt;OatFile&gt; oat_file(OatFile::Open(oat_location, oat_location, nullptr, !Runtime::Current()-&gt;IsCompiler(), &amp;error_msg)); if (oat_file.get() == nullptr) &#123; std::string compound_msg = StringPrintf(\"\\nFailed to open generated oat file '%s': %s\", oat_location, error_msg.c_str()); error_msgs-&gt;push_back(compound_msg); return nullptr; &#125; return oat_file.release();&#125; GenerateOatFile是核心逻辑，这个函数大部分都是我们不关心的配置dex2oat参数就不贴出来了，最后会fork出一个新进程，然后在子进程里执行execv()调用dex2oat。看起来我们必然要执行dex2oat了？别慌，还有办法。虽然没有直接的开关去阻止dex2oat，但我们还有hook大法！生成oat最后是通过execv调用dex2oat进行的，所以我们可以hook掉execv函数，如果是执行dex2oat那么直接让这个进程退出即可！Lody大神的早期作品TurboDex就是这样实现的。不过这个项目其实还可以优化一下：TurboDex是使用的Substrate进行hook，这是一个inline hook库，而execv是来自libc.so的导出符号，其实直接通过GOT Hook就能hook到，没有必要去用inline hook，反而增加crash风险。 总结本来我只是为了研究DexClassLoader与PathClassLoader的区别的，网上的文章和实验的结果完全不一样，结果意外发现一个快速加载dex的方法，就写出来了 :)这个故事告诉我们，没事多看源码（手动滑稽）另外个人建议，快速加载dex之后后台可以开一个线程单独进行dex2oat，具体可以参考ArtDexOptimizer，下次启动的时候如果完成了可以直接用生成好的oat文件，毕竟用oat比直接加载dex快得多，而且更稳定~","categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://canyie.github.io/tags/android/"},{"name":"art","slug":"art","permalink":"https://canyie.github.io/tags/art/"},{"name":"dex","slug":"dex","permalink":"https://canyie.github.io/tags/dex/"}]},{"title":"试着写了一个类Xposed框架","slug":"a-new-xposed-style-framework","date":"2020-02-03T06:51:21.000Z","updated":"2020-02-05T06:10:23.000Z","comments":true,"path":"2020/02/03/a-new-xposed-style-framework/","link":"","permalink":"https://canyie.github.io/2020/02/03/a-new-xposed-style-framework/","excerpt":"新人第一次写博客，勿喷..本文也发布在知乎上 Xposed框架在Android上是神器般的存在，它给了普通用户随意定制系统的能力，各种骚操作层出不穷。随着咱对Android的了解越来越深（其实一点都不深..），逐渐冒出了自己写一个类Xposed框架的想法，最终搞出了这个勉强能用的半成品。代码在这：Dreamland &amp; Dreamland Manager ，代码写的很辣鸡，求轻喷QAQ接下来会介绍一下实现细节与遇到的问题。","text":"新人第一次写博客，勿喷..本文也发布在知乎上 Xposed框架在Android上是神器般的存在，它给了普通用户随意定制系统的能力，各种骚操作层出不穷。随着咱对Android的了解越来越深（其实一点都不深..），逐渐冒出了自己写一个类Xposed框架的想法，最终搞出了这个勉强能用的半成品。代码在这：Dreamland &amp; Dreamland Manager ，代码写的很辣鸡，求轻喷QAQ接下来会介绍一下实现细节与遇到的问题。 注入 zygote 进程我们想实现Xposed那样在目标进程加载自己的模块，就必须把我们自己的代码注入到目标进程，而且我们的代码执行的时机还需要足够早，一般来说都是选择直接注入到zygote进程。 先来看看其他框架的实现： Xposed ：Xposed for art 重新实现了app_process，libart.so等重要系统库，安装时会替换这些文件，而各大厂商几乎没有不修改它们的，一旦被替换很可能变砖，导致Xposed在非原生系统上的稳定性很差。 EdXposed : EdXp依赖 Riru 而Riru是通过替换libmemtrack.so来实现，这个so库会在zygote进程启动时被加载，并且比libart轻得多（只有10个导出函数），然后就可以在zygote进程里执行任意代码。 太极阳 : 太极阳通过一种我看不懂的魔法（看了一下只发现libjit.so，但weishu表示Android系统里并没有一个这样一个库，所以并不是简单替换so）注入进zygote（以前是替换libprocessgroup.so） 可以看出，其他框架几乎都通过直接替换系统已有的so库实现，而替换已有so库则需要尽量选择较轻的库，以避免厂商的修改导致的问题。然而，我们没法避免厂商在so里加料，如果厂商修改了这个so库，我们直接把我们自己以AOSP为蓝本写的so替换上去，则会导致严重的问题。有没有别的什么办法？下面介绍梦境的实现方式。（注：如无特别说明，本文中的AOSP源码都是 7.0.0_r36 对应的代码）我们知道，在android中，所有的应用进程都是由zygote进程fork出来的，而zygote对应的可执行文件就是app_process（具体可以看init.rc）app_process的main方法如下： 12345678910111213141516int main(int argc, char* const argv[])&#123; // 省略无关代码... AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv)); // 省略无关代码... if (zygote) &#123; runtime.start(\"com.android.internal.os.ZygoteInit\", args, zygote); &#125; else if (className) &#123; runtime.start(\"com.android.internal.os.RuntimeInit\", args, zygote); &#125; else &#123; fprintf(stderr, \"Error: no class name or --zygote supplied.\\n\"); app_usage(); LOG_ALWAYS_FATAL(\"app_process: no class name or --zygote supplied.\"); return 10; &#125;&#125; 可以发现，是通过AppRuntime启动的，而AppRuntime继承自AndroidRuntime，start方法的实现在AndroidRuntime里 1234567891011121314151617181920212223242526272829/* * Start the Android runtime. This involves starting the virtual machine * and calling the \"static void main(String[] args)\" method in the class * named by \"className\". * * Passes the main function two arguments, the class name and the specified * options string. */void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote)&#123; // 省略无关代码... /* start the virtual machine */ JniInvocation jni_invocation; jni_invocation.Init(NULL); JNIEnv* env; if (startVm(&amp;mJavaVM, &amp;env, zygote) != 0) &#123; return; &#125; onVmCreated(env); /* * Register android functions. */ if (startReg(env) &lt; 0) &#123; ALOGE(\"Unable to register all android natives\\n\"); return; &#125; // 省略无关代码...&#125; 注意startVm这个方法，我们点进去看看。 1234567891011121314151617181920212223242526272829303132/* * Start the Dalvik Virtual Machine. * * Various arguments, most determined by system properties, are passed in. * The \"mOptions\" vector is updated. * * CAUTION: when adding options in here, be careful not to put the * char buffer inside a nested scope. Adding the buffer to the * options using mOptions.add() does not copy the buffer, so if the * buffer goes out of scope the option may be overwritten. It's best * to put the buffer at the top of the function so that it is more * unlikely that someone will surround it in a scope at a later time * and thus introduce a bug. * * Returns 0 on success. */int AndroidRuntime::startVm(JavaVM** pJavaVM, JNIEnv** pEnv, bool zygote)&#123; // 省略无关代码... /* * Initialize the VM. * * The JavaVM* is essentially per-process, and the JNIEnv* is per-thread. * If this call succeeds, the VM is ready, and we can start issuing * JNI calls. */ if (JNI_CreateJavaVM(pJavaVM, pEnv, &amp;initArgs) &lt; 0) &#123; ALOGE(\"JNI_CreateJavaVM failed\\n\"); return -1; &#125; return 0;&#125; 接下来看JNI_CreateJavaVM方法： 123456789101112131415161718192021222324252627282930313233343536// JNI Invocation interface.extern \"C\" jint JNI_CreateJavaVM(JavaVM** p_vm, JNIEnv** p_env, void* vm_args) &#123; ScopedTrace trace(__FUNCTION__); const JavaVMInitArgs* args = static_cast&lt;JavaVMInitArgs*&gt;(vm_args); if (IsBadJniVersion(args-&gt;version)) &#123; LOG(ERROR) &lt;&lt; \"Bad JNI version passed to CreateJavaVM: \" &lt;&lt; args-&gt;version; return JNI_EVERSION; &#125; RuntimeOptions options; for (int i = 0; i &lt; args-&gt;nOptions; ++i) &#123; JavaVMOption* option = &amp;args-&gt;options[i]; options.push_back(std::make_pair(std::string(option-&gt;optionString), option-&gt;extraInfo)); &#125; bool ignore_unrecognized = args-&gt;ignoreUnrecognized; if (!Runtime::Create(options, ignore_unrecognized)) &#123; return JNI_ERR; &#125; // Initialize native loader. This step makes sure we have // everything set up before we start using JNI. android::InitializeNativeLoader(); Runtime* runtime = Runtime::Current(); bool started = runtime-&gt;Start(); if (!started) &#123; delete Thread::Current()-&gt;GetJniEnv(); delete runtime-&gt;GetJavaVM(); LOG(WARNING) &lt;&lt; \"CreateJavaVM failed\"; return JNI_ERR; &#125; *p_env = Thread::Current()-&gt;GetJniEnv(); *p_vm = runtime-&gt;GetJavaVM(); return JNI_OK;&#125; 这个函数不长，我就直接全部贴出来了。注意看android::InitializeNativeLoader()，这个函数直接调用了g_namespaces-&gt;Initialize()，而g_namespaces是一个LibraryNamespaces指针，继续看下去，我们发现了宝藏： 123456789101112131415161718192021222324252627282930void Initialize() &#123; std::vector&lt;std::string&gt; sonames; const char* android_root_env = getenv(\"ANDROID_ROOT\"); std::string root_dir = android_root_env != nullptr ? android_root_env : \"/system\"; std::string public_native_libraries_system_config = root_dir + kPublicNativeLibrariesSystemConfigPathFromRoot; LOG_ALWAYS_FATAL_IF(!ReadConfig(public_native_libraries_system_config, &amp;sonames), \"Error reading public native library list from \\\"%s\\\": %s\", public_native_libraries_system_config.c_str(), strerror(errno)); // 省略无关代码 // This file is optional, quietly ignore if the file does not exist. ReadConfig(kPublicNativeLibrariesVendorConfig, &amp;sonames); // android_init_namespaces() expects all the public libraries // to be loaded so that they can be found by soname alone. // // TODO(dimitry): this is a bit misleading since we do not know // if the vendor public library is going to be opened from /vendor/lib // we might as well end up loading them from /system/lib // For now we rely on CTS test to catch things like this but // it should probably be addressed in the future. for (const auto&amp; soname : sonames) &#123; dlopen(soname.c_str(), RTLD_NOW | RTLD_NODELETE); &#125; public_libraries_ = base::Join(sonames, ':');&#125; public_native_libraries_system_config=/system/etc/public.libraries.txt，而ReadConfig方法很简单，读取传进来的文件路径，按行分割，忽略空行和以#开头的行，然后把这行push_back到传进来的vector里。所以这个函数做了这几件事： 读取/system/etc/public.libraries.txt和/vendor/etc/public.libraries.txt 挨个dlopen这两个txt文件里提到的所有so库 注：这里分析的源码是7.0.0的，在7.0往后的所有版本（截至本文发布）你都能找到类似的逻辑。 知道了这件事注入zygote就好办多了嘛！只要把我们自己写的so库扔到/system/lib下面（64位是/syste/lib64），然后在/system/etc/public.libraries.txt里把我们自己的文件加上去，这样zygote启动的时候就会去加载我们的so库，然后我们写一个函数，加上__attribute__((constructor))，这样这个函数就会在so库被加载的时候被调用，我们就完成了注入逻辑；而且这个文件是一个txt文件，只需要追加一行文件名就行，即使厂商做了修改也不用担心，稳定性棒棒哒！ （注1：此方法是我看一篇博客时看见的，那篇博客吐槽“在public.libraries.txt里加上的so库竟然会在zygote启动时被加载，每次修改都要重启手机才能生效，多不方便调试”，但是他抱怨的特性却成为了我的曙光，可惜找不到那篇博客了，没法贴出来…）（注2：在我大致完成了核心逻辑之后，我在EdXp的源码里发现了这个文件 ；这个部分看起来是使用whale进行java hook的方案，但是我从来没有听说过有使用纯whale进行java hook的EdXp版本，并且我在install.sh中没有看见操作public.libraries.txt，所以不太懂他想用这个文件干什么 :( ） ok，现在我们完成了注入zygote进程的逻辑，刚完成的时候我想，完成了注入部分，ART Hook部分也有很多开源库，那么实现一个xposed不是很简单的事吗？果然我还是太年轻… 监控应用进程启动前面我们注入了zygote进程，然而这样还不够，我们还需要监控应用进程启动并在应用进程执行代码才行。 刚开始我的想法很简单：直接在zygote里随便用art hook技术hook掉几个java方法；不过在我们的so库被加载的时候Runtime还没启动完成，没法拿到JNIEnv（就算拿到也用不了），这个也好办，native inline hook掉几个会在Runtime初始化完成时调用的函数就行，然并卵，提示无法分配可执行内存。 wtf？？为什么分配内存会失败？内存满了？没对齐？最后终于发现这样一条log： type=1400 audit(0.0:5): avc: denied { execmem } for scontext=u:r:zygote:s0 tcontext=u:r:zygote:s0 tclass=process permissive=0 上网查了一下，这条log代表zygote进程的context（u:r:zygote:s0）不允许分配可执行的匿名内存。这就麻烦了呀，很多事都做不了了（包括java方法的inline hook），想过很多办法（比如替换sepolicy），最后都被我否决了。那怎么办？最后打算去看EdXp的处理方式，没看见任何有关SELinux的部分，似乎是让magisk处理，不过我的是模拟器，没法装magisk。 这个问题困扰了我很久，最后，在Riru的源码里发现了另一种实现方案：通过GOT Hook拦截jniRegisterNativeMethods，然后就可以替换部分关键JNI函数。 简单来说，当发生跨ELF的函数调用时，会去.got表里查这个函数的绝对地址，然后再跳转过去，所以我们直接改这个表就能达到hook的目的，更多实现细节可以看xhook的说明文档。 这种方式的好处是不需要直接操作内存中的指令，不需要去手动分配可执行内存，所以不会受到SELinux的限制；缺点也很明显，如果人家不查.got表，就无法hook了。所以这种方式一般用于hook系统函数，比如来自libc的malloc, open等函数。 好了，GOT Hook并不是重点，接下来Riru使用xhook hook了libandroid_runtime.so对jniRegisterNativeMethods方法（来自libnativehelper.so）的调用，这样就能拦截一部分的JNI方法调用了。为什么说是一部分？因为另一部分JNI函数的实现在libart里，这一部分函数直接通过env-&gt;RegisterNativeMethods完成注册，所以无法hook。 之后riru在被替换的jniRegisterNativeMethods中动了一点小手脚：如果正在注册来自Zygote类的JNI方法，那么会把nativeForkSystemServer和nativeForkAndSpecialize替换成自己的实现，这样就能拦截system_server与应用进程的启动了！ Riru的这个方案非常好，但是还有优化空间：nativeForkAndSpecialize这个函数基本上每个版本都会变签名，而且各个厂商也会做修改，Riru的办法很简单：比对签名，如果签名不对那么就不会替换。不过，实际上我们并不需要那么精密的监控进程启动，让我们来找一下有没有其他的hook点。 大家都知道的，zygote进程最终会进入ZygoteInit.main，在main方法里fork出system_server，然后进入死循环接收来自AMS的请求fork出新进程。 12345678910public static void main(String argv[]) &#123; // 省略无关代码... if (startSystemServer) &#123; startSystemServer(abiList, socketName); &#125; // 省略无关代码... Log.i(TAG, \"Accepting command socket connections\"); runSelectLoop(abiList); // 省略无关代码...&#125; 在startSystemServer里会fork出system_server，runSelectLoop中会进入死循环等待创建进程请求，然后fork出应用进程。 12345678910111213141516171819202122/** * Prepare the arguments and fork for the system server process. */private static boolean startSystemServer(String abiList, String socketName) throws MethodAndArgsCaller, RuntimeException &#123; // 省略无关代码... /* Request to fork the system server process */ pid = Zygote.forkSystemServer( parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, null, parsedArgs.permittedCapabilities, parsedArgs.effectiveCapabilities); /* For child process */ if (pid == 0) &#123; // 注：返回0代表子进程 if (hasSecondZygote(abiList)) &#123; waitForSecondaryZygote(socketName); &#125; handleSystemServerProcess(parsedArgs); &#125;&#125; 点进去handleSystemServerProcess里看看： 12345678910111213141516171819202122/** * Finish remaining work for the newly forked system server process. */ private static void handleSystemServerProcess( ZygoteConnection.Arguments parsedArgs) throws ZygoteInit.MethodAndArgsCaller &#123; // 省略无关代码... if (parsedArgs.invokeWith != null) &#123; // 走不进去，省略 &#125; else &#123; ClassLoader cl = null; if (systemServerClasspath != null) &#123; cl = createSystemServerClassLoader(systemServerClasspath, parsedArgs.targetSdkVersion); Thread.currentThread().setContextClassLoader(cl); &#125; /* * Pass the remaining arguments to SystemServer. */ RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl); &#125; &#125; 最终会进入RuntimeInit.zygoteInit（7.x，对于8.x与以上在ZygoteInit.zygoteInit），记住这一点 然后，应用进程的创建是在runSelectLoop()里，最后会通过ZygoteConnection.runOnce进行处理 12345678910111213141516171819202122232425262728293031323334/** * Reads one start command from the command socket. If successful, * a child is forked and a &#123;@link ZygoteInit.MethodAndArgsCaller&#125; * exception is thrown in that child while in the parent process, * the method returns normally. On failure, the child is not * spawned and messages are printed to the log and stderr. Returns * a boolean status value indicating whether an end-of-file on the command * socket has been encountered. * * @return false if command socket should continue to be read from, or * true if an end-of-file has been encountered. * @throws ZygoteInit.MethodAndArgsCaller trampoline to invoke main() * method in child process */boolean runOnce() throws ZygoteInit.MethodAndArgsCaller &#123; //忽略无关代码 pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet, parsedArgs.appDataDir); // 忽略无关代码 if (pid == 0) &#123; // 子进程 // in child IoUtils.closeQuietly(serverPipeFd); serverPipeFd = null; handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr); // should never get here, the child is expected to either // throw ZygoteInit.MethodAndArgsCaller or exec(). return true; &#125; else &#123; // 忽略 &#125;&#125; 12345678910111213141516171819202122232425/** * Handles post-fork setup of child proc, closing sockets as appropriate, * reopen stdio as appropriate, and ultimately throwing MethodAndArgsCaller * if successful or returning if failed. * * @param parsedArgs non-null; zygote args * @param descriptors null-ok; new file descriptors for stdio if available. * @param pipeFd null-ok; pipe for communication back to Zygote. * @param newStderr null-ok; stream to use for stderr until stdio * is reopened. * * @throws ZygoteInit.MethodAndArgsCaller on success to * trampoline to code that invokes static main. */private void handleChildProc(Arguments parsedArgs, FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr) throws ZygoteInit.MethodAndArgsCaller &#123; // 忽略无关代码 if (parsedArgs.invokeWith != null) &#123; // 走不进去，省略 &#125; else &#123; RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, null /* classLoader */); &#125;&#125; 最后也是通过RuntimeInit.zygoteInit（7.x，对于8.x与以上在ZygoteInit.zygoteInit）完成。点进去看看有没有hook点： 123456789101112131415161718192021222324/** * The main function called when started through the zygote process. This * could be unified with main(), if the native code in nativeFinishInit() * were rationalized with Zygote startup.&lt;p&gt; * * Current recognized args: * &lt;ul&gt; * &lt;li&gt; &lt;code&gt; [--] &amp;lt;start class name&amp;gt; &amp;lt;args&amp;gt; * &lt;/ul&gt; * * @param targetSdkVersion target SDK version * @param argv arg strings */public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; if (DEBUG) Slog.d(TAG, \"RuntimeInit: Starting application from zygote\"); Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"RuntimeInit\"); redirectLogStreams(); commonInit(); nativeZygoteInit(); applicationInit(targetSdkVersion, argv, classLoader);&#125; 注意到那个nativeZygoteInit没有！！很明显是个native方法，而且是我们可以hook到的native方法！！这样子我们就可以直接在jniRegisterNativeMethods里替换掉这个方法了！而且这个方法从7.0到10.0也只有过一次改变：从RuntimeInit搬到ZygoteInit，比nativeForkAndSpecialize稳得多。（然而现在看来某些操作还是需要比较精细的监控的，以后再改吧） 加载Xposed模块这一部分其实是最简单的，目前已经有很多开源的ART Hook库，拿来就能用，需要自己写的地方也不需要跟太久的系统函数调用。目前是选择了SandHook作为核心ART Hook库，主要是已经提供好了Xposed API，很方便。然后是模块管理，因为没有那么多时间去弄，所以只是简单的把对应的配置文件设置成谁都能读，当然以后会优化。 未来注：本段内容没有什么营养，可以直接跳过。 编译打包自动化对，目前连自动化打包都没实现，还是手动拿dex等等然后手动压缩进去… 支持magisk安装现在只支持通过安装脚本直接修改/system，如果能够支持magisk模块式安装会少很多麻烦，比如如果变砖了只需要用mm管理器把模块给删了就好了 支持重要系统进程加载模块由于SELinux限制，目前不支持关键系统进程（如Zygote和system_server）加载模块，我这边没有什么很好的解决办法，求各位大佬赐教 :)顺便列出一些其他的限制：android 9，隐藏API访问限制，这个好办，绕过方式有很多，就不细讲了。Android 9及以上，zygote&amp;system_server还有其他系统应用会SetOnlyUseSystemOatFiles()，然后就不能加载不在/system下面的oat文件了，如果违反这个策略就会直接abort掉。android zygote fork新进程时，如果有不在白名单中的文件描述符，会进到ZygoteFailure里，然后整个进程abort掉。 配置文件加载部分因为在目标进程里加载模块肯定需要获取对应的配置，目前的做法是，把对应的配置文件设置成谁都能读，然后直接读这个文件就行，这样做当然不妥，所以计划以后去优化，比如优化成单独跑一个配置守护进程，只有这个进程能去读写配置，其他应用只能通过跨进程交互的方式拿到配置。 重新实现Xposed API目前梦境的Xposed API是SandHook自带的xposedcompat，通过DexMaker动态创建新的dex实现适配，这么做没有什么兼容性问题，但是有很大的效率问题，如果是第一次创建这个方法，需要生成dex，一套流程走下来可能就要用上100+ms。在xposedcompat_new中，有另一种实现方案：通过动态代理动态生成方法，然后把这个方法设置成native，对应的native函数也是通过libffi动态生成的，在这个native方法里跳到分发函数执行。这个方案对我来说很不错，至少不会太慢。（当然稳定性存疑） 结语目前梦境框架还有非常多的不足，目前只能当个PoC用，如果你有兴趣，不妨一起来玩 ^_^核心：Dreamland配套的管理器 Dreamland ManagerQQ群：949888394","categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://canyie.github.io/tags/android/"},{"name":"art","slug":"art","permalink":"https://canyie.github.io/tags/art/"},{"name":"AOP","slug":"AOP","permalink":"https://canyie.github.io/tags/AOP/"},{"name":"hook","slug":"hook","permalink":"https://canyie.github.io/tags/hook/"},{"name":"xposed","slug":"xposed","permalink":"https://canyie.github.io/tags/xposed/"}]},{"title":"我也有自己的个人博客啦！","slug":"hello-world","date":"2019-10-28T12:39:23.000Z","updated":"2020-04-15T03:05:17.501Z","comments":true,"path":"2019/10/28/hello-world/","link":"","permalink":"https://canyie.github.io/2019/10/28/hello-world/","excerpt":"我也有自己的个人博客啦！","text":"我也有自己的个人博客啦！ 基于GitHub Pages + Hexo，主题为Volantis本站地址：https://canyie.github.io/","categories":[],"tags":[{"name":"闲聊","slug":"闲聊","permalink":"https://canyie.github.io/tags/%E9%97%B2%E8%81%8A/"}]}],"categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://canyie.github.io/tags/android/"},{"name":"art","slug":"art","permalink":"https://canyie.github.io/tags/art/"},{"name":"AOP","slug":"AOP","permalink":"https://canyie.github.io/tags/AOP/"},{"name":"hook","slug":"hook","permalink":"https://canyie.github.io/tags/hook/"},{"name":"xposed","slug":"xposed","permalink":"https://canyie.github.io/tags/xposed/"},{"name":"dex","slug":"dex","permalink":"https://canyie.github.io/tags/dex/"},{"name":"闲聊","slug":"闲聊","permalink":"https://canyie.github.io/tags/%E9%97%B2%E8%81%8A/"}]}