<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>残页的小博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://canyie.github.io/"/>
  <updated>2020-04-15T03:08:44.350Z</updated>
  <id>https://canyie.github.io/</id>
  
  <author>
    <name>残页</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一种在ART上快速加载dex的方法</title>
    <link href="https://canyie.github.io/2020/02/15/fast-load-dex-on-art-runtime/"/>
    <id>https://canyie.github.io/2020/02/15/fast-load-dex-on-art-runtime/</id>
    <published>2020-02-15T02:02:33.000Z</published>
    <updated>2020-04-15T03:08:44.350Z</updated>
    
    <content type="html"><![CDATA[<p>在国内的大环境下，Android上插件化/热修复等技术百花齐放，而这一切都基于代码的动态加载。Android提供了一个DexClassLoader。用这个API能成功加载dex，但有一个比较严重的问题：Android Q以下，当这个dex被加载时，如果没有已经生成的oat，则会执行一次dex2oat把这个dex编译为oat，导致第一次加载dex会非常非常慢。个人认为这样的设计是非常不合理的，虽然转换成oat之后执行会很快，但完全可以让用户以解释器模式先愉快的用着，dex2oat放另一个线程执行多好。Android 8.0上谷歌还提供了一个InMemoryDexClassLoader，而以前的Android版本，就要开发者自己想办法了……</p><a id="more"></a><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>注：为了说明此方法能在较低版本的ART上运行，本文分析的源码是<a href="http://aospxref.com/android-5.0.0_r7.0.1/" target="_blank" rel="noopener">Android 5.0</a>的源码，之后的Android版本里OpenDexFileFromOat方法搬到了OatFileManager里，而调用dex2oat的部分则重构到了OatFileAssistant中，大致逻辑相同，感兴趣的可以自己去看看；至于Android 4.4，简单扫了一下源码似乎是生成oat失败就会直接抛一个IOException拒绝加载，emmm……</p><p>我们在Java代码里用<code>new DexClassLoader()</code>的方式加载dex，最后会调用到<code>DexFile.openDexFileNative</code>中，这个函数的<a href="http://aospxref.com/android-5.0.0_r7.0.1/xref/art/runtime/native/dalvik_system_DexFile.cc#101" target="_blank" rel="noopener">实现</a>是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">DexFile_openDexFileNative</span><span class="params">(JNIEnv* env, jclass, jstring javaSourceName, jstring javaOutputName, jint)</span> </span>&#123;</span><br><span class="line">  <span class="function">ScopedUtfChars <span class="title">sourceName</span><span class="params">(env, javaSourceName)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (sourceName.c_str() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">NullableScopedUtfChars <span class="title">outputName</span><span class="params">(env, javaOutputName)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (env-&gt;ExceptionCheck()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ClassLinker* linker = Runtime::Current()-&gt;GetClassLinker();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> DexFile*&gt;&gt; dex_files(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> DexFile*&gt;());</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; error_msgs;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> success = linker-&gt;OpenDexFilesFromOat(sourceName.c_str(), outputName.c_str(), &amp;error_msgs,</span><br><span class="line">                                             dex_files.get());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (success || !dex_files-&gt;empty()) &#123;</span><br><span class="line">    <span class="comment">// In the case of non-success, we have not found or could not generate the oat file.</span></span><br><span class="line">    <span class="comment">// But we may still have found a dex file that we can use.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;jlong&gt;(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(dex_files.release()));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 加载失败的情况，省略</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的注释很有意思，如果返回false（生成oat失败），但是有被成功加载的dex，那么还是应该当做成功。<br>可以看出具体实现在ClassLinker中的OpenDexFilesFromOat里，我们点进去看看：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Multidex files make it possible that some, but not all, dex files can be broken/outdated. This</span></span><br><span class="line"><span class="comment">// complicates the loading process, as we should not use an iterative loading process, because that</span></span><br><span class="line"><span class="comment">// would register the oat file and dex files that come before the broken one. Instead, check all</span></span><br><span class="line"><span class="comment">// multidex ahead of time.</span></span><br><span class="line"><span class="keyword">bool</span> ClassLinker::OpenDexFilesFromOat(<span class="keyword">const</span> <span class="keyword">char</span>* dex_location, <span class="keyword">const</span> <span class="keyword">char</span>* oat_location,</span><br><span class="line">                                      <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;* error_msgs,</span><br><span class="line">                                      <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> DexFile*&gt;* dex_files) &#123;</span><br><span class="line">  <span class="comment">// 1) Check whether we have an open oat file.</span></span><br><span class="line">  <span class="comment">// This requires a dex checksum, use the "primary" one.</span></span><br><span class="line">  <span class="keyword">bool</span> needs_registering = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> OatFile::OatDexFile* oat_dex_file = FindOpenedOatDexFile(oat_location, dex_location,</span><br><span class="line">                                                                 dex_location_checksum_pointer);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">const</span> OatFile&gt; open_oat_file(</span><br><span class="line">      oat_dex_file != <span class="literal">nullptr</span> ? oat_dex_file-&gt;GetOatFile() : <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2) If we do not have an open one, maybe there's one on disk already.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// In case the oat file is not open, we play a locking game here so</span></span><br><span class="line">  <span class="comment">// that if two different processes race to load and register or generate</span></span><br><span class="line">  <span class="comment">// (or worse, one tries to open a partial generated file) we will be okay.</span></span><br><span class="line">  <span class="comment">// This is actually common with apps that use DexClassLoader to work</span></span><br><span class="line">  <span class="comment">// around the dex method reference limit and that have a background</span></span><br><span class="line">  <span class="comment">// service running in a separate process.</span></span><br><span class="line">  ScopedFlock scoped_flock;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (open_oat_file.get() == <span class="literal">nullptr</span>) &#123; </span><br><span class="line">    <span class="keyword">if</span> (oat_location != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> error_msg;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// We are loading or creating one in the future. Time to set up the file lock.</span></span><br><span class="line">      <span class="keyword">if</span> (!scoped_flock.Init(oat_location, &amp;error_msg)) &#123;</span><br><span class="line">        error_msgs-&gt;push_back(error_msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// TODO Caller specifically asks for this oat_location. We should honor it. Probably?</span></span><br><span class="line">      open_oat_file.reset(FindOatFileInOatLocationForDexFile(dex_location, dex_location_checksum,</span><br><span class="line">                                                             oat_location, &amp;error_msg));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (open_oat_file.get() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> compound_msg = StringPrintf(<span class="string">"Failed to find dex file '%s' in oat location '%s': %s"</span>,</span><br><span class="line">                                                dex_location, oat_location, error_msg.c_str());</span><br><span class="line">        VLOG(class_linker) &lt;&lt; compound_msg;</span><br><span class="line">        error_msgs-&gt;push_back(compound_msg);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> What to lock here?</span></span><br><span class="line">      <span class="keyword">bool</span> obsolete_file_cleanup_failed;</span><br><span class="line">      open_oat_file.reset(FindOatFileContainingDexFileFromDexLocation(dex_location,</span><br><span class="line">                                                                      dex_location_checksum_pointer,</span><br><span class="line">                                                                      kRuntimeISA, error_msgs,</span><br><span class="line">                                                                      &amp;obsolete_file_cleanup_failed));</span><br><span class="line">      <span class="comment">// There's no point in going forward and eventually try to regenerate the</span></span><br><span class="line">      <span class="comment">// file if we couldn't remove the obsolete one. Mostly likely we will fail</span></span><br><span class="line">      <span class="comment">// with the same error when trying to write the new file.</span></span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> should we maybe do this only when we get permission issues? (i.e. EACCESS).</span></span><br><span class="line">      <span class="keyword">if</span> (obsolete_file_cleanup_failed) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    needs_registering = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3) If we have an oat file, check all contained multidex files for our dex_location.</span></span><br><span class="line">  <span class="comment">// Note: LoadMultiDexFilesFromOatFile will check for nullptr in the first argument.</span></span><br><span class="line">  <span class="keyword">bool</span> success = LoadMultiDexFilesFromOatFile(open_oat_file.get(), dex_location,</span><br><span class="line">                                              dex_location_checksum_pointer,</span><br><span class="line">                                              <span class="literal">false</span>, error_msgs, dex_files);</span><br><span class="line">  <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      <span class="comment">// 我们没有有效的oat文件，所以不会走到这里</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (needs_registering) &#123;</span><br><span class="line">      <span class="comment">// We opened it, delete it.</span></span><br><span class="line">      open_oat_file.reset();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      open_oat_file.release();  <span class="comment">// Do not delete open oat files.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4) If it's not the case (either no oat file or mismatches), regenerate and load.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Look in cache location if no oat_location is given.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> cache_location;</span><br><span class="line">  <span class="keyword">if</span> (oat_location == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// Use the dalvik cache.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">dalvik_cache</span><span class="params">(GetDalvikCacheOrDie(GetInstructionSetString(kRuntimeISA)))</span></span>;</span><br><span class="line">    cache_location = GetDalvikCacheFilenameOrDie(dex_location, dalvik_cache.c_str());</span><br><span class="line">    oat_location = cache_location.c_str();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> has_flock = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// Definitely need to lock now.</span></span><br><span class="line">  <span class="keyword">if</span> (!scoped_flock.HasFile()) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> error_msg;</span><br><span class="line">    <span class="keyword">if</span> (!scoped_flock.Init(oat_location, &amp;error_msg)) &#123;</span><br><span class="line">      error_msgs-&gt;push_back(error_msg);</span><br><span class="line">      has_flock = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (Runtime::Current()-&gt;IsDex2OatEnabled() &amp;&amp; has_flock &amp;&amp; scoped_flock.HasFile()) &#123;</span><br><span class="line">    <span class="comment">// Create the oat file.</span></span><br><span class="line">    open_oat_file.reset(CreateOatFileForDexLocation(dex_location, scoped_flock.GetFile()-&gt;Fd(),</span><br><span class="line">                                                    oat_location, error_msgs));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Failed, bail.</span></span><br><span class="line">  <span class="keyword">if</span> (open_oat_file.get() == <span class="literal">nullptr</span>) &#123; <span class="comment">// 如果无法生成oat，那么直接加载dex</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> error_msg;</span><br><span class="line">    <span class="comment">// dex2oat was disabled or crashed. Add the dex file in the list of dex_files to make progress.</span></span><br><span class="line">    DexFile::Open(dex_location, dex_location, &amp;error_msg, dex_files);</span><br><span class="line">    error_msgs-&gt;push_back(error_msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 再次尝试加载oat，无关，省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数比较长，所以做了一点精简。<br>我们在这里看到了一点端倪，这个函数做了这些事情：</p><ol><li>检查我们是否已经有一个打开了的oat</li><li>如果没有，那么检查oat缓存目录（创建DexClassLoader时传入的第二个参数）是否已经有了一个oat，并且检查这个oat的有效性</li><li>如果没有或者这个oat是无效的，那么生成一个oat文件</li></ol><p>我们首次加载dex时，肯定没有有效的oat，最后会生成一个新的oat：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Runtime::Current()-&gt;IsDex2OatEnabled() &amp;&amp; has_flock &amp;&amp; scoped_flock.HasFile()) &#123;</span><br><span class="line">  <span class="comment">// Create the oat file.</span></span><br><span class="line">  open_oat_file.reset(CreateOatFileForDexLocation(dex_location, scoped_flock.GetFile()-&gt;Fd(),</span><br><span class="line">                                                  oat_location, error_msgs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个if判断，直接决定是否进行dex2oat，我们看看能不能通过各种手段让这个判断不成立。</p><h2 id="禁用dex2oat"><a href="#禁用dex2oat" class="headerlink" title="禁用dex2oat"></a>禁用dex2oat</h2><h3 id="第一招：修改Runtime中的变量"><a href="#第一招：修改Runtime中的变量" class="headerlink" title="第一招：修改Runtime中的变量"></a>第一招：修改Runtime中的变量</h3><p>这个if判断里，第一个条件就是<code>Runtime::Current()-&gt;IsDex2OatEnabled()</code>，如果返回false，那么就不会生成oat。这个函数的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsDex2OatEnabled</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> dex2oat_enabled_ &amp;&amp; IsImageDex2OatEnabled();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsImageDex2OatEnabled</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> image_dex2oat_enabled_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dex2oat_enabled_</code>与<code>image_dex2oat_enabled_</code>都是Runtime对象中的成员变量，而Runtime可以通过JavaVM获取，<strong>所以我们只需要修改这个值就能禁用dex2oat</strong>。已经有其他人实现了这一步，具体可以看看<a href="https://fucknmb.com/2018/12/30/art-dex2oat%E5%8A%A0%E8%BD%BD%E5%8A%A0%E9%80%9F%E6%B5%85%E6%9E%90/" target="_blank" rel="noopener">这篇博客</a>。<br>然而事情真的会这么简单吗？<br>查看源码发现<strong>Runtime是一个炒鸡大的结构体</strong>，Android里有什么东西都往这扔，你几乎可以从Runtime对象上直接或间接获取到任何东西，然而也正是因为Runtime太大了，使得没有什么好的办法获取里面的值。</p><p>让我们看看还有没有其他方法：</p><h3 id="第二招：使用PathClassLoader"><a href="#第二招：使用PathClassLoader" class="headerlink" title="第二招：使用PathClassLoader"></a>第二招：使用PathClassLoader</h3><p>我们可以看见，在if判断里，还有两个条件：<code>has_flock</code>和<code>scoped_flock.HasFile()</code>，让我们看看是否可以让这两个条件不成立。<br><code>has_flock</code>的赋值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> has_flock = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// Definitely need to lock now.</span></span><br><span class="line"><span class="keyword">if</span> (!scoped_flock.HasFile()) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> error_msg;</span><br><span class="line">  <span class="keyword">if</span> (!scoped_flock.Init(oat_location, &amp;error_msg)) &#123;</span><br><span class="line">    error_msgs-&gt;push_back(error_msg);</span><br><span class="line">    has_flock = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又是scoped_flock，看看在上面scoped_flock可能在哪里被初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ScopedFlock scoped_flock;</span><br><span class="line"><span class="keyword">if</span> (open_oat_file.get() == <span class="literal">nullptr</span>) &#123; </span><br><span class="line">  <span class="keyword">if</span> (oat_location != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> error_msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We are loading or creating one in the future. Time to set up the file lock.</span></span><br><span class="line">    <span class="keyword">if</span> (!scoped_flock.Init(oat_location, &amp;error_msg)) &#123;</span><br><span class="line">      error_msgs-&gt;push_back(error_msg);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看ScopedFlock的Init方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ScopedFlock::Init(<span class="keyword">const</span> <span class="keyword">char</span>* filename, <span class="built_in">std</span>::<span class="built_in">string</span>* error_msg) &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    file_.reset(OS::OpenFileWithFlags(filename, O_CREAT | O_RDWR));</span><br><span class="line">    <span class="keyword">if</span> (file_.get() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      *error_msg = StringPrintf(<span class="string">"Failed to open file '%s': %s"</span>, filename, strerror(errno));</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略一大堆代码……</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看见，会打开这个文件，flags为O_CREAT | O_RDWR，那我们只需要设置oat_location为不可写的路径，就能让ScopedFlock::Init返回false。不过我们要注意的是，如果oat_location不为null并且无法使用，那在上面的一个判断里就会直接返回false。怎么办？</p><p>是时候请出我们的主角<code>PathClassLoader</code>了！</p><p>PathClassLoader作为DexClassLoader的兄弟<del>（也可能是姐妹？）</del>，受到的待遇与DexClassLoader截然不同：网上讲解动态加载dex的文章几乎都只讲DexClassLoader，而对于PathClassLoader则是一笔带过：“PathClassLoader只能加载系统中已经安装过的apk”。<br>然而事实真的是这样吗？或许Android 5.0以前是，但Android 5.0时就已经可以加载外部dex了，今天我要为PathClassLoader正名！<br>让我们来对比一下DexClassLoader和PathClassLoader的源码。<br>DexClassLoader：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DexClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DexClassLoader</span><span class="params">(String dexPath, String optimizedDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">            String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">new</span> File(optimizedDirectory), libraryPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对，你没看错，有效代码就这么点。<br>让我们再看看PathClassLoader的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, <span class="keyword">null</span>, parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, String libraryPath,</span></span></span><br><span class="line"><span class="function"><span class="params">            ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, libraryPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上所以实现代码都在BaseDexClassLoader中，DexClassLoader和PathClassLoader都调用了同一个构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDexClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DexPathList pathList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">            String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.pathList = <span class="keyword">new</span> DexPathList(<span class="keyword">this</span>, dexPath, libraryPath, optimizedDirectory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意第二个参数，optimizedDirectory，<strong>DexClassLoader传入的是new File(optimizedDirectory)，而PathClassLoader传入的是null。</strong>记住这一点。<br>这两种情况最后都会调用到DexFile.openDexFileNative中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">openDexFileNative</span><span class="params">(String sourceName, String outputName, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>如果是PathClassLoader，outputName为null，会进入这个if分支中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look in cache location if no oat_location is given.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> cache_location;</span><br><span class="line"><span class="keyword">if</span> (oat_location == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  <span class="comment">// Use the dalvik cache.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">dalvik_cache</span><span class="params">(GetDalvikCacheOrDie(GetInstructionSetString(kRuntimeISA)))</span></span>;</span><br><span class="line">  cache_location = GetDalvikCacheFilenameOrDie(dex_location, dalvik_cache.c_str());</span><br><span class="line">  oat_location = cache_location.c_str();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<strong>会把oat_location设置成/data/dalvik-cache/下的路径</strong>，接下来因为<strong>我们根本没有对dalvik-cache的写入权限</strong>，所以无法打开fd，然后就会走到这里<strong>直接加载原始dex</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (open_oat_file.get() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> error_msg;</span><br><span class="line">  <span class="comment">// dex2oat was disabled or crashed. Add the dex file in the list of dex_files to make progress.</span></span><br><span class="line">  DexFile::Open(dex_location, dex_location, &amp;error_msg, dex_files);</span><br><span class="line">  error_msgs-&gt;push_back(error_msg);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此整个逻辑已经明朗，通过PathClassLoader加载会把oat输出路径设置成/data/dalvik-cache/下，然后因为我们没有对dalvik-cache的写入权限，所以无法打开fd，之后会直接加载原始dex，不会进行dex2oat。<br>（注：本文分析源码是<a href="http://aospxref.com/android-5.0.0_r7.0.1/" target="_blank" rel="noopener">Android 5.0</a>，<strong>在<a href="http://aospxref.com/android-8.1.0_r65/" target="_blank" rel="noopener">Android 8.1</a>时源码有改动</strong>，就算是DexClassLoader也会把optimizedDirectory设置成null，输出的oat在dex的父目录/oat/下，所以无法通过PathClassLoader快速加载dex，但在8.1时已经有InMemoryDexClassLoader了，直接通过InMemoryDexClassLoader加载就好了。</p><p>简单做了个小测试，在我的AVD（Android 7.1.1）上，用DexClassLoader加载75M的qq apk用了近80秒，并生成了一个313M的oat，而PathClassLoader用时稳定在2秒左右，emmm……</p><p>看起来我们已经有一个比较好的办法禁用dex2oat了，不过需要修改源码没法直接全局禁用，修改Runtime风险又太大，让我们看看还有没有其他方法。</p><h3 id="第三招：hook-execv"><a href="#第三招：hook-execv" class="headerlink" title="第三招：hook execv"></a>第三招：hook execv</h3><p>到了这里，上面那个判断肯定会成立了，似乎进行dex2oat已成定局？我们继续看CreateOatFileForDexLocation。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OatFile* ClassLinker::CreateOatFileForDexLocation(<span class="keyword">const</span> <span class="keyword">char</span>* dex_location,</span><br><span class="line">                                                        <span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span>* oat_location,</span><br><span class="line">                                                        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;* error_msgs) &#123;</span><br><span class="line">  <span class="comment">// Generate the output oat file for the dex file</span></span><br><span class="line">  VLOG(class_linker) &lt;&lt; <span class="string">"Generating oat file "</span> &lt;&lt; oat_location &lt;&lt; <span class="string">" for "</span> &lt;&lt; dex_location;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> error_msg;</span><br><span class="line">  <span class="keyword">if</span> (!GenerateOatFile(dex_location, fd, oat_location, &amp;error_msg)) &#123;</span><br><span class="line">    CHECK(!error_msg.empty());</span><br><span class="line">    error_msgs-&gt;push_back(error_msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;OatFile&gt; oat_file(OatFile::Open(oat_location, oat_location, <span class="literal">nullptr</span>,</span><br><span class="line">                                            !Runtime::Current()-&gt;IsCompiler(),</span><br><span class="line">                                            &amp;error_msg));</span><br><span class="line">  <span class="keyword">if</span> (oat_file.get() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> compound_msg = StringPrintf(<span class="string">"\nFailed to open generated oat file '%s': %s"</span>,</span><br><span class="line">                                            oat_location, error_msg.c_str());</span><br><span class="line">    error_msgs-&gt;push_back(compound_msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> oat_file.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GenerateOatFile是核心逻辑，这个函数大部分都是我们不关心的配置dex2oat参数就不贴出来了，最后会fork出一个新进程，然后在子进程里执行execv()调用dex2oat。<br>看起来我们必然要执行dex2oat了？别慌，还有办法。虽然没有直接的开关去阻止dex2oat，但<strong>我们还有hook大法</strong>！生成oat最后是通过execv调用dex2oat进行的，所以我们可以<strong>hook掉execv函数，如果是执行dex2oat那么直接让这个进程退出即可</strong>！Lody大神的早期作品<a href="https://github.com/asLody/TurboDex" target="_blank" rel="noopener">TurboDex</a>就是这样实现的。不过这个项目其实还可以优化一下：TurboDex是使用的Substrate进行hook，这是一个inline hook库，而execv是来自libc.so的导出符号，其实直接通过GOT Hook就能hook到，没有必要去用inline hook，反而增加crash风险。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本来我只是为了研究DexClassLoader与PathClassLoader的区别的，网上的文章和实验的结果完全不一样，结果意外发现一个快速加载dex的方法，就写出来了 :)<br>这个故事告诉我们，没事多看源码（手动滑稽）<br>另外个人建议，快速加载dex之后后台可以开一个线程单独进行dex2oat，具体可以参考<a href="https://github.com/canyie/DreamlandManager/blob/master/app/src/main/java/com/canyie/dreamland/manager/utils/ArtDexOptimizer.java" target="_blank" rel="noopener">ArtDexOptimizer</a>，下次启动的时候如果完成了可以直接用生成好的oat文件，毕竟用oat比直接加载dex快得多，而且更稳定~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在国内的大环境下，Android上插件化/热修复等技术百花齐放，而这一切都基于代码的动态加载。Android提供了一个DexClassLoader。用这个API能成功加载dex，但有一个比较严重的问题：Android Q以下，当这个dex被加载时，如果没有已经生成的oat，则会执行一次dex2oat把这个dex编译为oat，导致第一次加载dex会非常非常慢。个人认为这样的设计是非常不合理的，虽然转换成oat之后执行会很快，但完全可以让用户以解释器模式先愉快的用着，dex2oat放另一个线程执行多好。Android 8.0上谷歌还提供了一个InMemoryDexClassLoader，而以前的Android版本，就要开发者自己想办法了……&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="android" scheme="https://canyie.github.io/tags/android/"/>
    
      <category term="art" scheme="https://canyie.github.io/tags/art/"/>
    
      <category term="dex" scheme="https://canyie.github.io/tags/dex/"/>
    
  </entry>
  
  <entry>
    <title>试着写了一个类Xposed框架</title>
    <link href="https://canyie.github.io/2020/02/03/a-new-xposed-style-framework/"/>
    <id>https://canyie.github.io/2020/02/03/a-new-xposed-style-framework/</id>
    <published>2020-02-03T06:51:21.000Z</published>
    <updated>2020-02-05T06:10:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>新人第一次写博客，勿喷..<br>本文也发布在<a href="https://zhuanlan.zhihu.com/p/104871958" target="_blank" rel="noopener">知乎</a>上</p><p>Xposed框架在Android上是神器般的存在，它给了普通用户随意定制系统的能力，各种骚操作层出不穷。随着咱对Android的了解越来越深（其实一点都不深..），逐渐冒出了自己写一个类Xposed框架的想法，最终搞出了这个勉强能用的半成品。<br>代码在这：<a href="https://github.com/canyie/Dreamland" target="_blank" rel="noopener">Dreamland</a> &amp; <a href="https://github.com/canyie/DreamlandManager" target="_blank" rel="noopener">Dreamland Manager</a> ，代码写的很辣鸡，求轻喷QAQ<br>接下来会介绍一下实现细节与遇到的问题。</p><a id="more"></a><h2 id="注入-zygote-进程"><a href="#注入-zygote-进程" class="headerlink" title="注入 zygote 进程"></a>注入 zygote 进程</h2><p>我们想实现Xposed那样在目标进程加载自己的模块，就必须把我们自己的代码注入到目标进程，而且我们的代码执行的时机还需要足够早，一般来说都是选择直接注入到zygote进程。</p><p>先来看看其他框架的实现：</p><ul><li><a href="https://github.com/rovo89/Xposed" target="_blank" rel="noopener">Xposed</a> ：Xposed for art 重新实现了app_process，libart.so等重要系统库，安装时会替换这些文件，而各大厂商几乎没有不修改它们的，一旦被替换很可能变砖，导致Xposed在非原生系统上的稳定性很差。</li><li><a href="https://github.com/ElderDrivers/EdXposed" target="_blank" rel="noopener">EdXposed</a> : EdXp依赖 <a href="https://github.com/RikkaApps/Riru" target="_blank" rel="noopener">Riru</a> 而Riru是通过替换libmemtrack.so来实现，这个so库会在zygote进程启动时被加载，并且比libart轻得多（只有10个导出函数），然后就可以在zygote进程里执行任意代码。</li><li><a href="https://github.com/taichi-framework/TaiChi" target="_blank" rel="noopener">太极阳</a> : 太极阳通过一种我看不懂的魔法（看了一下只发现libjit.so，但weishu表示Android系统里并没有一个这样一个库，所以并不是简单替换so）注入进zygote（以前是替换libprocessgroup.so）</li></ul><p>可以看出，其他框架几乎都通过直接替换系统已有的so库实现，而替换已有so库则需要尽量选择较轻的库，以避免厂商的修改导致的问题。然而，我们没法避免厂商在so里加料，如果厂商修改了这个so库，我们直接把我们自己以AOSP为蓝本写的so替换上去，则会导致严重的问题。<br>有没有别的什么办法？下面介绍梦境的实现方式。<br>（注：如无特别说明，本文中的AOSP源码都是 <a href="http://aospxref.com/android-7.0.0_r36" target="_blank" rel="noopener">7.0.0_r36</a> 对应的代码）<br>我们知道，在android中，所有的应用进程都是由zygote进程fork出来的，而zygote对应的可执行文件就是app_process（具体可以看init.rc）<br>app_process的main方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 省略无关代码...</span></span><br><span class="line">  <span class="function">AppRuntime <span class="title">runtime</span><span class="params">(argv[<span class="number">0</span>], computeArgBlockSize(argc, argv))</span></span>;</span><br><span class="line">  <span class="comment">// 省略无关代码...</span></span><br><span class="line">  <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">    runtime.start(<span class="string">"com.android.internal.os.ZygoteInit"</span>, args, zygote);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">    runtime.start(<span class="string">"com.android.internal.os.RuntimeInit"</span>, args, zygote);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error: no class name or --zygote supplied.\n"</span>);</span><br><span class="line">    app_usage();</span><br><span class="line">    LOG_ALWAYS_FATAL(<span class="string">"app_process: no class name or --zygote supplied."</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，是通过AppRuntime启动的，而AppRuntime继承自AndroidRuntime，start方法的实现在AndroidRuntime里</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Start the Android runtime.  This involves starting the virtual machine</span></span><br><span class="line"><span class="comment"> * and calling the "static void main(String[] args)" method in the class</span></span><br><span class="line"><span class="comment"> * named by "className".</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Passes the main function two arguments, the class name and the specified</span></span><br><span class="line"><span class="comment"> * options string.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> AndroidRuntime::start(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 省略无关代码...</span></span><br><span class="line">  <span class="comment">/* start the virtual machine */</span></span><br><span class="line">  JniInvocation jni_invocation;</span><br><span class="line">  jni_invocation.Init(<span class="literal">NULL</span>);</span><br><span class="line">  JNIEnv* env;</span><br><span class="line">  <span class="keyword">if</span> (startVm(&amp;mJavaVM, &amp;env, zygote) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  onVmCreated(env);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Register android functions.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    ALOGE(<span class="string">"Unable to register all android natives\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 省略无关代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意startVm这个方法，我们点进去看看。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Start the Dalvik Virtual Machine.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Various arguments, most determined by system properties, are passed in.</span></span><br><span class="line"><span class="comment"> * The "mOptions" vector is updated.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CAUTION: when adding options in here, be careful not to put the</span></span><br><span class="line"><span class="comment"> * char buffer inside a nested scope.  Adding the buffer to the</span></span><br><span class="line"><span class="comment"> * options using mOptions.add() does not copy the buffer, so if the</span></span><br><span class="line"><span class="comment"> * buffer goes out of scope the option may be overwritten.  It's best</span></span><br><span class="line"><span class="comment"> * to put the buffer at the top of the function so that it is more</span></span><br><span class="line"><span class="comment"> * unlikely that someone will surround it in a scope at a later time</span></span><br><span class="line"><span class="comment"> * and thus introduce a bug.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns 0 on success.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> AndroidRuntime::startVm(JavaVM** pJavaVM, JNIEnv** pEnv, <span class="keyword">bool</span> zygote)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 省略无关代码...</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Initialize the VM.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * The JavaVM* is essentially per-process, and the JNIEnv* is per-thread.</span></span><br><span class="line"><span class="comment">   * If this call succeeds, the VM is ready, and we can start issuing</span></span><br><span class="line"><span class="comment">   * JNI calls.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">if</span> (JNI_CreateJavaVM(pJavaVM, pEnv, &amp;initArgs) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      ALOGE(<span class="string">"JNI_CreateJavaVM failed\n"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看JNI_CreateJavaVM方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JNI Invocation interface.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">jint <span class="title">JNI_CreateJavaVM</span><span class="params">(JavaVM** p_vm, JNIEnv** p_env, <span class="keyword">void</span>* vm_args)</span> </span>&#123;</span><br><span class="line">  <span class="function">ScopedTrace <span class="title">trace</span><span class="params">(__FUNCTION__)</span></span>;</span><br><span class="line">  <span class="keyword">const</span> JavaVMInitArgs* args = <span class="keyword">static_cast</span>&lt;JavaVMInitArgs*&gt;(vm_args);</span><br><span class="line">  <span class="keyword">if</span> (IsBadJniVersion(args-&gt;version)) &#123;</span><br><span class="line">    LOG(ERROR) &lt;&lt; <span class="string">"Bad JNI version passed to CreateJavaVM: "</span> &lt;&lt; args-&gt;version;</span><br><span class="line">    <span class="keyword">return</span> JNI_EVERSION;</span><br><span class="line">  &#125;</span><br><span class="line">  RuntimeOptions options;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args-&gt;nOptions; ++i) &#123;</span><br><span class="line">    JavaVMOption* option = &amp;args-&gt;options[i];</span><br><span class="line">    options.push_back(<span class="built_in">std</span>::make_pair(<span class="built_in">std</span>::<span class="built_in">string</span>(option-&gt;optionString), option-&gt;extraInfo));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> ignore_unrecognized = args-&gt;ignoreUnrecognized;</span><br><span class="line">  <span class="keyword">if</span> (!Runtime::Create(options, ignore_unrecognized)) &#123;</span><br><span class="line">    <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize native loader. This step makes sure we have</span></span><br><span class="line">  <span class="comment">// everything set up before we start using JNI.</span></span><br><span class="line">  android::InitializeNativeLoader();</span><br><span class="line"></span><br><span class="line">  Runtime* runtime = Runtime::Current();</span><br><span class="line">  <span class="keyword">bool</span> started = runtime-&gt;Start();</span><br><span class="line">  <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">    <span class="keyword">delete</span> Thread::Current()-&gt;GetJniEnv();</span><br><span class="line">    <span class="keyword">delete</span> runtime-&gt;GetJavaVM();</span><br><span class="line">    LOG(WARNING) &lt;&lt; <span class="string">"CreateJavaVM failed"</span>;</span><br><span class="line">    <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *p_env = Thread::Current()-&gt;GetJniEnv();</span><br><span class="line">  *p_vm = runtime-&gt;GetJavaVM();</span><br><span class="line">  <span class="keyword">return</span> JNI_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数不长，我就直接全部贴出来了。注意看android::InitializeNativeLoader()，这个函数直接调用了g_namespaces-&gt;Initialize()，而g_namespaces是一个LibraryNamespaces指针，继续看下去，我们发现了宝藏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; sonames;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* android_root_env = getenv(<span class="string">"ANDROID_ROOT"</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> root_dir = android_root_env != <span class="literal">nullptr</span> ? android_root_env : <span class="string">"/system"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> public_native_libraries_system_config =</span><br><span class="line">          root_dir + kPublicNativeLibrariesSystemConfigPathFromRoot;</span><br><span class="line"></span><br><span class="line">  LOG_ALWAYS_FATAL_IF(!ReadConfig(public_native_libraries_system_config, &amp;sonames),</span><br><span class="line">                      <span class="string">"Error reading public native library list from \"%s\": %s"</span>,</span><br><span class="line">                      public_native_libraries_system_config.c_str(), strerror(errno));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略无关代码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// This file is optional, quietly ignore if the file does not exist.</span></span><br><span class="line">  ReadConfig(kPublicNativeLibrariesVendorConfig, &amp;sonames);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// android_init_namespaces() expects all the public libraries</span></span><br><span class="line">  <span class="comment">// to be loaded so that they can be found by soname alone.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// TODO(dimitry): this is a bit misleading since we do not know</span></span><br><span class="line">  <span class="comment">// if the vendor public library is going to be opened from /vendor/lib</span></span><br><span class="line">  <span class="comment">// we might as well end up loading them from /system/lib</span></span><br><span class="line">  <span class="comment">// For now we rely on CTS test to catch things like this but</span></span><br><span class="line">  <span class="comment">// it should probably be addressed in the future.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; soname : sonames) &#123;</span><br><span class="line">    dlopen(soname.c_str(), RTLD_NOW | RTLD_NODELETE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public_libraries_ = base::Join(sonames, <span class="string">':'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>public_native_libraries_system_config=/system/etc/public.libraries.txt，而ReadConfig方法很简单，读取传进来的文件路径，按行分割，忽略空行和以#开头的行，然后把这行push_back到传进来的vector里。<br>所以这个函数做了这几件事：</p><ol><li>读取/system/etc/public.libraries.txt和/vendor/etc/public.libraries.txt</li><li><strong>挨个dlopen这两个txt文件里提到的所有so库</strong></li></ol><p>注：这里分析的源码是7.0.0的，在7.0往后的所有版本（截至本文发布）你都能找到类似的逻辑。</p><p>知道了这件事注入zygote就好办多了嘛！只要把我们自己写的so库扔到/system/lib下面（64位是/syste/lib64），然后在/system/etc/public.libraries.txt里把我们自己的文件加上去，这样zygote启动的时候就会去加载我们的so库，然后我们写一个函数，加上__attribute__((constructor))，这样这个函数就会在so库被加载的时候被调用，我们就完成了注入逻辑；而且这个文件是一个txt文件，只需要追加一行文件名就行，即使厂商做了修改也不用担心，稳定性棒棒哒！</p><p>（注1：此方法是我看一篇博客时看见的，那篇博客吐槽“在public.libraries.txt里加上的so库竟然会在zygote启动时被加载，每次修改都要重启手机才能生效，多不方便调试”，但是他抱怨的特性却成为了我的曙光，可惜找不到那篇博客了，没法贴出来…）<br>（注2：在我大致完成了核心逻辑之后，我在EdXp的源码里发现了<a href="https://github.com/ElderDrivers/EdXposed/blob/master/edxp-whale/template_override/system/etc/public.libraries-edxp.txt" target="_blank" rel="noopener">这个文件</a> ；这个部分看起来是使用whale进行java hook的方案，但是我从来没有听说过有使用纯whale进行java hook的EdXp版本，并且我在install.sh中没有看见操作public.libraries.txt，所以不太懂他想用这个文件干什么 :( ）</p><p>ok，现在我们完成了注入zygote进程的逻辑，刚完成的时候我想，完成了注入部分，ART Hook部分也有很多开源库，那么实现一个xposed不是很简单的事吗？果然我还是太年轻…</p><h2 id="监控应用进程启动"><a href="#监控应用进程启动" class="headerlink" title="监控应用进程启动"></a>监控应用进程启动</h2><p>前面我们注入了zygote进程，然而这样还不够，我们还需要监控应用进程启动并在应用进程执行代码才行。</p><p>刚开始我的想法很简单：直接在zygote里随便用art hook技术hook掉几个java方法；不过在我们的so库被加载的时候Runtime还没启动完成，没法拿到JNIEnv（就算拿到也用不了），这个也好办，native inline hook掉几个会在Runtime初始化完成时调用的函数就行，然并卵，提示无法分配可执行内存。</p><p>wtf？？为什么分配内存会失败？内存满了？没对齐？最后终于发现这样一条log：</p><p><code>type=1400 audit(0.0:5): avc: denied { execmem } for scontext=u:r:zygote:s0 tcontext=u:r:zygote:s0 tclass=process permissive=0</code> </p><p>上网查了一下，这条log代表zygote进程的context（u:r:zygote:s0）不允许分配可执行的匿名内存。这就麻烦了呀，很多事都做不了了（包括java方法的inline hook），想过很多办法（比如替换sepolicy），最后都被我否决了。那怎么办？最后打算去看EdXp的处理方式，没看见任何有关SELinux的部分，似乎是让magisk处理，不过我的是模拟器，没法装magisk。</p><p>这个问题困扰了我很久，最后，在Riru的源码里发现了另一种实现方案：通过GOT Hook拦截jniRegisterNativeMethods，然后就可以替换部分关键JNI函数。</p><p>简单来说，当发生跨ELF的函数调用时，会去.got表里查这个函数的绝对地址，然后再跳转过去，所以我们直接改这个表就能达到hook的目的，更多实现细节可以看<a href="https://github.com/iqiyi/xHook/blob/master/docs/overview/android_plt_hook_overview.zh-CN.md" target="_blank" rel="noopener">xhook的说明文档</a>。</p><p>这种方式的好处是不需要直接操作内存中的指令，不需要去手动分配可执行内存，所以不会受到SELinux的限制；缺点也很明显，如果人家不查.got表，就无法hook了。所以这种方式一般用于hook系统函数，比如来自libc的malloc, open等函数。</p><p>好了，GOT Hook并不是重点，接下来Riru使用xhook hook了libandroid_runtime.so对jniRegisterNativeMethods方法（来自libnativehelper.so）的调用，这样就能拦截一部分的JNI方法调用了。为什么说是<strong>一部分</strong>？因为另一部分JNI函数的实现在libart里，这一部分函数直接通过env-&gt;RegisterNativeMethods完成注册，所以无法hook。</p><p>之后riru在被替换的jniRegisterNativeMethods中动了一点小手脚：如果正在注册来自Zygote类的JNI方法，那么会把nativeForkSystemServer和nativeForkAndSpecialize替换成自己的实现，这样就能拦截system_server与应用进程的启动了！</p><p>Riru的这个方案非常好，但是还有优化空间：nativeForkAndSpecialize这个函数基本上每个版本都会变签名，而且各个厂商也会做修改，Riru的办法很简单：比对签名，如果签名不对那么就不会替换。不过，实际上我们并不需要那么精密的监控进程启动，让我们来找一下有没有其他的hook点。</p><p>大家都知道的，zygote进程最终会进入ZygoteInit.main，在main方法里fork出system_server，然后进入死循环接收来自AMS的请求fork出新进程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略无关代码...</span></span><br><span class="line">    <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">        startSystemServer(abiList, socketName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略无关代码...</span></span><br><span class="line">    Log.i(TAG, <span class="string">"Accepting command socket connections"</span>);</span><br><span class="line">    runSelectLoop(abiList);</span><br><span class="line">    <span class="comment">// 省略无关代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在startSystemServer里会fork出system_server，runSelectLoop中会进入死循环等待创建进程请求，然后fork出应用进程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prepare the arguments and fork for the system server process.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">startSystemServer</span><span class="params">(String abiList, String socketName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> MethodAndArgsCaller, RuntimeException </span>&#123;</span><br><span class="line">    <span class="comment">// 省略无关代码...</span></span><br><span class="line">    <span class="comment">/* Request to fork the system server process */</span></span><br><span class="line">    pid = Zygote.forkSystemServer(</span><br><span class="line">            parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">            parsedArgs.gids,</span><br><span class="line">            parsedArgs.debugFlags,</span><br><span class="line">            <span class="keyword">null</span>,</span><br><span class="line">            parsedArgs.permittedCapabilities,</span><br><span class="line">            parsedArgs.effectiveCapabilities);</span><br><span class="line">    <span class="comment">/* For child process */</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// 注：返回0代表子进程</span></span><br><span class="line">        <span class="keyword">if</span> (hasSecondZygote(abiList)) &#123;</span><br><span class="line">            waitForSecondaryZygote(socketName);</span><br><span class="line">        &#125;</span><br><span class="line">        handleSystemServerProcess(parsedArgs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点进去handleSystemServerProcess里看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finish remaining work for the newly forked system server process.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleSystemServerProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">         ZygoteConnection.Arguments parsedArgs)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">     <span class="comment">// 省略无关代码...</span></span><br><span class="line">     <span class="keyword">if</span> (parsedArgs.invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 走不进去，省略</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         ClassLoader cl = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">if</span> (systemServerClasspath != <span class="keyword">null</span>) &#123;</span><br><span class="line">             cl = createSystemServerClassLoader(systemServerClasspath,</span><br><span class="line">                                                parsedArgs.targetSdkVersion);</span><br><span class="line">             Thread.currentThread().setContextClassLoader(cl);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">          * Pass the remaining arguments to SystemServer.</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>最终会进入RuntimeInit.zygoteInit（7.x，对于8.x与以上在ZygoteInit.zygoteInit），记住这一点</p><p>然后，应用进程的创建是在runSelectLoop()里，最后会通过ZygoteConnection.runOnce进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reads one start command from the command socket. If successful,</span></span><br><span class="line"><span class="comment"> * a child is forked and a &#123;<span class="doctag">@link</span> ZygoteInit.MethodAndArgsCaller&#125;</span></span><br><span class="line"><span class="comment"> * exception is thrown in that child while in the parent process,</span></span><br><span class="line"><span class="comment"> * the method returns normally. On failure, the child is not</span></span><br><span class="line"><span class="comment"> * spawned and messages are printed to the log and stderr. Returns</span></span><br><span class="line"><span class="comment"> * a boolean status value indicating whether an end-of-file on the command</span></span><br><span class="line"><span class="comment"> * socket has been encountered.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> false if command socket should continue to be read from, or</span></span><br><span class="line"><span class="comment"> * true if an end-of-file has been encountered.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ZygoteInit.MethodAndArgsCaller trampoline to invoke main()</span></span><br><span class="line"><span class="comment"> * method in child process</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">runOnce</span><span class="params">()</span> <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    <span class="comment">//忽略无关代码</span></span><br><span class="line">    pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</span><br><span class="line">                parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</span><br><span class="line">                parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,</span><br><span class="line">                parsedArgs.appDataDir);</span><br><span class="line">    <span class="comment">// 忽略无关代码</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">        <span class="comment">// in child</span></span><br><span class="line">        IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">        serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line">        handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// should never get here, the child is expected to either</span></span><br><span class="line">        <span class="comment">// throw ZygoteInit.MethodAndArgsCaller or exec().</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 忽略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handles post-fork setup of child proc, closing sockets as appropriate,</span></span><br><span class="line"><span class="comment"> * reopen stdio as appropriate, and ultimately throwing MethodAndArgsCaller</span></span><br><span class="line"><span class="comment"> * if successful or returning if failed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parsedArgs non-null; zygote args</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> descriptors null-ok; new file descriptors for stdio if available.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pipeFd null-ok; pipe for communication back to Zygote.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newStderr null-ok; stream to use for stderr until stdio</span></span><br><span class="line"><span class="comment"> * is reopened.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ZygoteInit.MethodAndArgsCaller on success to</span></span><br><span class="line"><span class="comment"> * trampoline to code that invokes static main.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleChildProc</span><span class="params">(Arguments parsedArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">        FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    <span class="comment">// 忽略无关代码 </span></span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 走不进去，省略</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,</span><br><span class="line">                parsedArgs.remainingArgs, <span class="keyword">null</span> <span class="comment">/* classLoader */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后也是通过RuntimeInit.zygoteInit（7.x，对于8.x与以上在ZygoteInit.zygoteInit）完成。点进去看看有没有hook点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The main function called when started through the zygote process. This</span></span><br><span class="line"><span class="comment"> * could be unified with main(), if the native code in nativeFinishInit()</span></span><br><span class="line"><span class="comment"> * were rationalized with Zygote startup.&lt;p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Current recognized args:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt; &lt;code&gt; [--] &amp;lt;start class name&amp;gt;  &amp;lt;args&amp;gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetSdkVersion target SDK version</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> argv arg strings</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"RuntimeInit: Starting application from zygote"</span>);</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"RuntimeInit"</span>);</span><br><span class="line">    redirectLogStreams();</span><br><span class="line"></span><br><span class="line">    commonInit();</span><br><span class="line">    nativeZygoteInit();</span><br><span class="line">    applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到那个nativeZygoteInit没有！！很明显是个native方法，而且是我们可以hook到的native方法！！这样子我们就可以直接在jniRegisterNativeMethods里替换掉这个方法了！而且这个方法从7.0到10.0也只有过一次改变：从RuntimeInit搬到ZygoteInit，比nativeForkAndSpecialize稳得多。<br>（然而现在看来某些操作还是需要比较精细的监控的，以后再改吧）</p><h2 id="加载Xposed模块"><a href="#加载Xposed模块" class="headerlink" title="加载Xposed模块"></a>加载Xposed模块</h2><p>这一部分其实是最简单的，目前已经有很多开源的ART Hook库，拿来就能用，需要自己写的地方也不需要跟太久的系统函数调用。<br>目前是选择了<a href="https://github.com/ganyao114/SandHook" target="_blank" rel="noopener">SandHook</a>作为核心ART Hook库，主要是已经提供好了Xposed API，很方便。<br>然后是模块管理，因为没有那么多时间去弄，所以只是简单的把对应的配置文件设置成谁都能读，当然以后会优化。</p><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>注：本段内容没有什么营养，可以直接跳过。</p><h3 id="编译打包自动化"><a href="#编译打包自动化" class="headerlink" title="编译打包自动化"></a>编译打包自动化</h3><p>对，目前连自动化打包都没实现，还是手动拿dex等等然后手动压缩进去…</p><h3 id="支持magisk安装"><a href="#支持magisk安装" class="headerlink" title="支持magisk安装"></a>支持magisk安装</h3><p>现在只支持通过安装脚本直接修改/system，如果能够支持magisk模块式安装会少很多麻烦，比如如果变砖了只需要用mm管理器把模块给删了就好了 </p><h3 id="支持重要系统进程加载模块"><a href="#支持重要系统进程加载模块" class="headerlink" title="支持重要系统进程加载模块"></a>支持重要系统进程加载模块</h3><p>由于SELinux限制，目前不支持关键系统进程（如Zygote和system_server）加载模块，我这边没有什么很好的解决办法，求各位大佬赐教 :)<br>顺便列出一些其他的限制：<br>android 9，隐藏API访问限制，这个好办，绕过方式有很多，就不细讲了。<br>Android 9及以上，zygote&amp;system_server还有其他系统应用会SetOnlyUseSystemOatFiles()，然后就不能加载不在/system下面的oat文件了，如果违反这个策略就会直接abort掉。<br>android zygote fork新进程时，如果有不在白名单中的文件描述符，会进到ZygoteFailure里，然后整个进程abort掉。</p><h3 id="配置文件加载部分"><a href="#配置文件加载部分" class="headerlink" title="配置文件加载部分"></a>配置文件加载部分</h3><p>因为在目标进程里加载模块肯定需要获取对应的配置，目前的做法是，把对应的配置文件设置成谁都能读，然后直接读这个文件就行，这样做当然不妥，所以计划以后去优化，比如优化成单独跑一个配置守护进程，只有这个进程能去读写配置，其他应用只能通过跨进程交互的方式拿到配置。</p><h3 id="重新实现Xposed-API"><a href="#重新实现Xposed-API" class="headerlink" title="重新实现Xposed API"></a>重新实现Xposed API</h3><p>目前梦境的Xposed API是SandHook自带的<a href="https://github.com/ganyao114/SandHook/tree/master/xposedcompat" target="_blank" rel="noopener">xposedcompat</a>，通过DexMaker动态创建新的dex实现适配，这么做没有什么兼容性问题，但是有很大的效率问题，如果是第一次创建这个方法，需要生成dex，一套流程走下来可能就要用上100+ms。<br>在<a href="https://github.com/ganyao114/SandHook/tree/master/xposedcompat_new" target="_blank" rel="noopener">xposedcompat_new</a>中，有另一种实现方案：通过动态代理动态生成方法，然后把这个方法设置成native，对应的native函数也是通过libffi动态生成的，在这个native方法里跳到分发函数执行。这个方案对我来说很不错，至少不会太慢。（当然稳定性存疑）</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>目前梦境框架还有非常多的不足，目前只能当个PoC用，如果你有兴趣，不妨一起来玩 ^_^<br>核心：<a href="https://github.com/canyie/Dreamland" target="_blank" rel="noopener">Dreamland</a><br>配套的管理器 <a href="https://github.com/canyie/DreamlandManager" target="_blank" rel="noopener">Dreamland Manager</a><br><a href="mqqwpa://im/chat?chat_type=group&uin=949888394&version=1">QQ群：949888394</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新人第一次写博客，勿喷..&lt;br&gt;本文也发布在&lt;a href=&quot;https://zhuanlan.zhihu.com/p/104871958&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;知乎&lt;/a&gt;上&lt;/p&gt;
&lt;p&gt;Xposed框架在Android上是神器般的存在，它给了普通用户随意定制系统的能力，各种骚操作层出不穷。随着咱对Android的了解越来越深（其实一点都不深..），逐渐冒出了自己写一个类Xposed框架的想法，最终搞出了这个勉强能用的半成品。&lt;br&gt;代码在这：&lt;a href=&quot;https://github.com/canyie/Dreamland&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dreamland&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://github.com/canyie/DreamlandManager&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dreamland Manager&lt;/a&gt; ，代码写的很辣鸡，求轻喷QAQ&lt;br&gt;接下来会介绍一下实现细节与遇到的问题。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="android" scheme="https://canyie.github.io/tags/android/"/>
    
      <category term="art" scheme="https://canyie.github.io/tags/art/"/>
    
      <category term="xposed" scheme="https://canyie.github.io/tags/xposed/"/>
    
      <category term="AOP" scheme="https://canyie.github.io/tags/AOP/"/>
    
      <category term="hook" scheme="https://canyie.github.io/tags/hook/"/>
    
  </entry>
  
  <entry>
    <title>我也有自己的个人博客啦！</title>
    <link href="https://canyie.github.io/2019/10/28/hello-world/"/>
    <id>https://canyie.github.io/2019/10/28/hello-world/</id>
    <published>2019-10-28T12:39:23.000Z</published>
    <updated>2020-04-15T03:05:17.501Z</updated>
    
    <content type="html"><![CDATA[<p>我也有自己的个人博客啦！</p><a id="more"></a><p>基于<a href="https://page.github.com" target="_blank" rel="noopener">GitHub Pages</a> + <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>，主题为<a href="https://github.com/xaoxuu/hexo-theme-volantis" target="_blank" rel="noopener">Volantis</a><br>本站地址：<a href="https://canyie.github.io/">https://canyie.github.io/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我也有自己的个人博客啦！&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="闲聊" scheme="https://canyie.github.io/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
</feed>
